}
#Q7 Runs several generations and returns species richness a each step
neutral_time_series = function(x, t) {
rich = (species_richness(x))
for (i in 1:t) {
x = neutral_generation(x)
rich = c(rich, species_richness(x))
}
return(rich)
}
#Q8 Uses neutral time series over 200 steps on a maximally diverse community and plots the richness
question_8 = function() {
rich = neutral_time_series(initialise_max(100), 2000)
plot(rich, main = "Species richness without new species",
ylab = "species richness",
xlab = "time steps")
}
question_8()
#Q9 creates a neutral step with either a speciation or a replacement, depending on value of v
neutral_step_speciation = function(x, v) {
p = runif(1)
if (v < p) {
index = choose_two(length(x))
x[index[1]] = x[index[2]]
}
else {
newspecies =  max(x) + 1
index = sample((length(x)), size = 1, replace = TRUE)
x[index] = newspecies
}
return(x)
}
#Q10 Takes a community and outputs new community after a few generations with speciation or replacement
neutral_generation_speciation = function(x, v) {
n =  round(length(x) / 2)
for (i in 1:n) {
x = neutral_step_speciation(x, v)
}
return(x)
}
#Q11 Returns community richness at each generation
neutral_time_series_speciation = function(x, v, t) {
rich = vector()
for (i in 1:t) {
x = neutral_generation_speciation(x, v)
rich[i] = species_richness(x)
}
return(rich)
}
question_12 = function() {
t = 200
v = 0.1
comm_max = initialise_max(100)
comm_min = initialise_min(100)
rich_max = neutral_time_series_speciation(comm_max, v, t)
rich_min = neutral_time_series_speciation(comm_min, v, t)
x = (1:t)
titles = c("Max", "Min")
y =  cbind(rich_max, rich_min)
colnames(y) = titles
matplot (x, y, pch = 19, col = 1:2, main = "Species richness over time with speciation")
legend(1,
50,
legend = colnames(y),
col = 1:2,
lty = 1:4)
}
question_12()
question_12b = function() {
t = 200
v = 0.1
comm_max = initialise_max(100)
comm_min = initialise_min(100)
rich_max = neutral_time_series_speciation(comm_max, v, t)
rich_min = neutral_time_series_speciation(comm_min, v, t)
y1 =  cbind(rich_max, rich_min)
v = 0.9
comm_max = initialise_max(100)
comm_min = initialise_min(100)
rich_max = neutral_time_series_speciation(comm_max, v, t)
rich_min = neutral_time_series_speciation(comm_min, v, t)
y2 =  cbind(rich_max, rich_min)
v = 0.1
comm_max = initialise_max(500)
comm_min = initialise_min(500)
rich_max = neutral_time_series_speciation(comm_max, v, t)
rich_min = neutral_time_series_speciation(comm_min, v, t)
y3 =  cbind(rich_max, rich_min)
v = 0.1
comm_max = initialise_max(1000)
comm_min = initialise_min(1000)
rich_max = neutral_time_series_speciation(comm_max, v, t)
rich_min = neutral_time_series_speciation(comm_min, v, t)
y4 =  cbind(rich_max, rich_min)
x = (1:t)
par(mfrow=c(2,2))
matplot (x, y1, pch = 19, col = 1:2, main = "v = 0.1, size = 100")
matplot (x, y2, pch = 19, col = 1:2, main = "v = 0.9, size = 100")
matplot (x, y3, pch = 19, col = 1:2, main = "v = 0.1, size = 500")
matplot (x, y4, pch = 19, col = 1:2, main = "v = 0.1, size = 1000")
}
question_12b()
#Q13 calcualte species abundance using table - which gives frequencies
species_abundance = function(x) {
abundance = as.numeric(sort(table(x), decreasing = TRUE))
return(abundance)
}
#Q14 Arrange the abundances into octets
octaves = function(x) {
oct = tabulate(floor(log2(x)) + 1)
return(oct)
}
#Q15 Need to add the octets produced by octaves() and average them, but each octet can be a different
#length, this function pads the shorter octet with zeros
sum_vect = function(x, y) {
if (length(x) < length(y))    {
short = x
long = y
newshort = c(x, rep(0, length(long) - length(short)))
sum = newshort + long
}   else if (length(x) > length(y)) {
short = y
long = x
newshort = c(y, rep(0, length(long) - length(short)))
sum = newshort + long
}   else  {
sum = x + y
}
return(sum)
}
#Q16, produce a barchart of octets after 200 generations burn-in, using another 2000 generations
#using v = 0.1, size = 100
question_16 = function() {
octets = list()
x = initialise_min(100)
v = 0.1
rich = vector()
i = 1
index = 1
# burn in
while (i < 2200) {
if (i < 200) {
x = neutral_generation_speciation(x, v)
} else {
# continue for 2000 cycles
x = neutral_generation_speciation(x, v)
if (i %% 20 == 0) {
abundance = species_abundance(x)
octets[[index]] = octaves(abundance)
index = index + 1
}
}
i = i + 1
}
#find the average of the octaves which are list elements of octets
l = length(octets)
sum = vector()
for (a in 1:(l)) {
sum = sum_vect(sum, octets[[a]])
}
ave = sum / l
names = names = c("1", "2,3", "4 -7", "8-31", "32-63", ">64")
barplot(ave,
names.arg = names,
main = "Average abundances in octets",
xlab = "abundances")
}
question_16()
get_series_average = function(richness_vector){
avg = vector()
avg = c(avg,richness_vector[1])
for ( i in 1:(length(richness_vector)-1)){
i = i + 1
tmpvect = richness_vector[1:i]
total = sum(tmpvect)
avgerage = total/length(tmpvect)
avg= c(avg, avgerage)
}
return(avg)
}
challenge_A = function(){
t = 200
v = 0.1
repeats = 500
#get two starting communities
comm_max = initialise_max(100)
comm_min = initialise_min(100)
#initialise richness vector
richness_max_vect = vector(length = t)
richness_min_vect = vector(length = t)
#initialise df for storing output for laer calculations
richness_df_max = data.frame()
richness_df_min = data.frame()
for (i in 1:repeats) {
#get times series of richness for them both - repeat this and store values for each repeat
rich_max = neutral_time_series_speciation(comm_max, v, t)
rich_min = neutral_time_series_speciation(comm_min, v, t)
richness_df_max = rbind(richness_df_max,rich_max)
richness_df_min = rbind(richness_df_min,rich_min)
}
#can be useful to name cols - otherwise first row can become a header
cols = c(1:t)
colnames(richness_df_max) = cols
colnames(richness_df_min) = cols
#calcualte the standard deviations and averages using the dataframe of stored richnesses
#because each run is a row the cols are used for sd and ave.
sd_max = sqrt(apply(richness_df_max,2,var))
sd_min = sqrt(apply(richness_df_min,2,var))
avg_max = colSums(richness_df_max)/repeats
avg_min = colSums(richness_df_min)/repeats
#for 97.2% CI we need 98.6th percentile = z of 2.2
CI_upper_max = avg_max + 2.2*sd_max
CI_lower_max = avg_max - 2.2*sd_max
CI_upper_min = avg_min + 2.2*sd_min
CI_lower_min = avg_min - 2.2*sd_min
#plot the graphs
x = (1:t)
titles = c("Maximum initial richness", "Minimum initial richness")
y =  cbind(avg_max, avg_min)
matplot (x, y, pch = 20, col = 1:2, xlim = c(0,t), ylim = c(0,100),
xlab = "time", ylab = "Average species richness",
main = "Average species richness for 500 repeats of neutral_time_series_speciation, initial community size 100")
legend(50,
100,
legend = titles,
col = 1:2,
lty = 1:4)
lines(CI_upper_max)
lines(CI_lower_max)
lines(CI_upper_min, col = "red")
lines(CI_lower_min, col = "red")
}
challenge_A()
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
graphics.off()
#generate random communities
generate_community = function(n,seed) {
set.seed(seed)
comm = sample(x = c(1:10),
size = n,
replace = TRUE)
return(comm)
}
#Q1 get species richness
species_richness = function(x) {
r = length(unique(x))
return(r)
}
#Q2 Get a maximally diverse community
initialise_max = function(x) {
comm = seq(1:x)
return(comm)
}
#Q3 get a minimally diverse community - everything is the same
initialise_min = function(x) {
comm = rep(1, x)
return(comm)
}
#Q4 Need for neutral_step functions, just select two numbers from within the length of
#input vector which can then be used as indices for speciation or death replacement
choose_two = function(x) {
two = sample(x, 2)
return(two)
}
#Q5 Uses choose two and then replaces species at index 1 with that at index 2
#Simulates a species dieing and being repalced by another within community
neutral_step = function(x) {
index = choose_two(length(x))
x[index[1]] = x[index[2]]
return(x)
}
#Q6 Su=imulates n steps of neutral step
neutral_generation = function(x) {
n = round(length(x) / 2)
for (i in 1:n) {
comm = neutral_step(x)
}
return(comm)
}
#Q7 Runs several generations and returns species richness a each step
neutral_time_series = function(x, t) {
rich = (species_richness(x))
for (i in 1:t) {
x = neutral_generation(x)
rich = c(rich, species_richness(x))
}
return(rich)
}
#Q8 Uses neutral time series over 200 steps on a maximally diverse community and plots the richness
question_8 = function() {
rich = neutral_time_series(initialise_max(100), 2000)
plot(rich, main = "Species richness without new species",
ylab = "species richness",
xlab = "time steps")
}
question_8()
#Q9 creates a neutral step with either a speciation or a replacement, depending on value of v
neutral_step_speciation = function(x, v) {
p = runif(1)
if (v < p) {
index = choose_two(length(x))
x[index[1]] = x[index[2]]
}
else {
newspecies =  max(x) + 1
index = sample((length(x)), size = 1, replace = TRUE)
x[index] = newspecies
}
return(x)
}
#Q10 Takes a community and outputs new community after a few generations with speciation or replacement
neutral_generation_speciation = function(x, v) {
n =  round(length(x) / 2)
for (i in 1:n) {
x = neutral_step_speciation(x, v)
}
return(x)
}
#Q11 Returns community richness at each generation
neutral_time_series_speciation = function(x, v, t) {
rich = vector()
for (i in 1:t) {
x = neutral_generation_speciation(x, v)
rich[i] = species_richness(x)
}
return(rich)
}
question_12 = function() {
t = 200
v = 0.1
comm_max = initialise_max(100)
comm_min = initialise_min(100)
rich_max = neutral_time_series_speciation(comm_max, v, t)
rich_min = neutral_time_series_speciation(comm_min, v, t)
x = (1:t)
titles = c("Max", "Min")
y =  cbind(rich_max, rich_min)
colnames(y) = titles
matplot (x, y, pch = 19, col = 1:2, main = "Species richness over time with speciation")
legend(1,
50,
legend = colnames(y),
col = 1:2,
lty = 1:4)
}
question_12()
question_12b = function() {
t = 200
v = 0.1
comm_max = initialise_max(100)
comm_min = initialise_min(100)
rich_max = neutral_time_series_speciation(comm_max, v, t)
rich_min = neutral_time_series_speciation(comm_min, v, t)
y1 =  cbind(rich_max, rich_min)
v = 0.9
comm_max = initialise_max(100)
comm_min = initialise_min(100)
rich_max = neutral_time_series_speciation(comm_max, v, t)
rich_min = neutral_time_series_speciation(comm_min, v, t)
y2 =  cbind(rich_max, rich_min)
v = 0.1
comm_max = initialise_max(500)
comm_min = initialise_min(500)
rich_max = neutral_time_series_speciation(comm_max, v, t)
rich_min = neutral_time_series_speciation(comm_min, v, t)
y3 =  cbind(rich_max, rich_min)
v = 0.1
comm_max = initialise_max(1000)
comm_min = initialise_min(1000)
rich_max = neutral_time_series_speciation(comm_max, v, t)
rich_min = neutral_time_series_speciation(comm_min, v, t)
y4 =  cbind(rich_max, rich_min)
x = (1:t)
par(mfrow=c(2,2))
matplot (x, y1, pch = 19, col = 1:2, main = "v = 0.1, size = 100")
matplot (x, y2, pch = 19, col = 1:2, main = "v = 0.9, size = 100")
matplot (x, y3, pch = 19, col = 1:2, main = "v = 0.1, size = 500")
matplot (x, y4, pch = 19, col = 1:2, main = "v = 0.1, size = 1000")
}
question_12b()
#Q13 calcualte species abundance using table - which gives frequencies
species_abundance = function(x) {
abundance = as.numeric(sort(table(x), decreasing = TRUE))
return(abundance)
}
#Q14 Arrange the abundances into octets
octaves = function(x) {
oct = tabulate(floor(log2(x)) + 1)
return(oct)
}
#Q15 Need to add the octets produced by octaves() and average them, but each octet can be a different
#length, this function pads the shorter octet with zeros
sum_vect = function(x, y) {
if (length(x) < length(y))    {
short = x
long = y
newshort = c(x, rep(0, length(long) - length(short)))
sum = newshort + long
}   else if (length(x) > length(y)) {
short = y
long = x
newshort = c(y, rep(0, length(long) - length(short)))
sum = newshort + long
}   else  {
sum = x + y
}
return(sum)
}
#Q16, produce a barchart of octets after 200 generations burn-in, using another 2000 generations
#using v = 0.1, size = 100
question_16 = function() {
octets = list()
x = initialise_min(100)
v = 0.1
rich = vector()
i = 1
index = 1
# burn in
while (i < 2200) {
if (i < 200) {
x = neutral_generation_speciation(x, v)
} else {
# continue for 2000 cycles
x = neutral_generation_speciation(x, v)
if (i %% 20 == 0) {
abundance = species_abundance(x)
octets[[index]] = octaves(abundance)
index = index + 1
}
}
i = i + 1
}
#find the average of the octaves which are list elements of octets
l = length(octets)
sum = vector()
for (a in 1:(l)) {
sum = sum_vect(sum, octets[[a]])
}
ave = sum / l
names = names = c("1", "2,3", "4 -7", "8-31", "32-63", ">64")
barplot(ave,
names.arg = names,
main = "Average abundances in octets",
xlab = "abundances")
}
question_16()
get_series_average = function(richness_vector){
avg = vector()
avg = c(avg,richness_vector[1])
for ( i in 1:(length(richness_vector)-1)){
i = i + 1
tmpvect = richness_vector[1:i]
total = sum(tmpvect)
avgerage = total/length(tmpvect)
avg= c(avg, avgerage)
}
return(avg)
}
challenge_A = function(){
t = 200
v = 0.1
repeats = 500
#get two starting communities
comm_max = initialise_max(100)
comm_min = initialise_min(100)
#initialise richness vector
richness_max_vect = vector(length = t)
richness_min_vect = vector(length = t)
#initialise df for storing output for laer calculations
richness_df_max = data.frame()
richness_df_min = data.frame()
for (i in 1:repeats) {
#get times series of richness for them both - repeat this and store values for each repeat
rich_max = neutral_time_series_speciation(comm_max, v, t)
rich_min = neutral_time_series_speciation(comm_min, v, t)
richness_df_max = rbind(richness_df_max,rich_max)
richness_df_min = rbind(richness_df_min,rich_min)
}
#can be useful to name cols - otherwise first row can become a header
cols = c(1:t)
colnames(richness_df_max) = cols
colnames(richness_df_min) = cols
#calcualte the standard deviations and averages using the dataframe of stored richnesses
#because each run is a row the cols are used for sd and ave.
sd_max = sqrt(apply(richness_df_max,2,var))
sd_min = sqrt(apply(richness_df_min,2,var))
avg_max = colSums(richness_df_max)/repeats
avg_min = colSums(richness_df_min)/repeats
#for 97.2% CI we need 98.6th percentile = z of 2.2
CI_upper_max = avg_max + 2.2*sd_max
CI_lower_max = avg_max - 2.2*sd_max
CI_upper_min = avg_min + 2.2*sd_min
CI_lower_min = avg_min - 2.2*sd_min
#plot the graphs
x = (1:t)
titles = c("Maximum initial richness", "Minimum initial richness")
y =  cbind(avg_max, avg_min)
matplot (x, y, pch = 20, col = 1:2, xlim = c(0,t), ylim = c(0,100),
xlab = "time", ylab = "Average species richness",
main = "Average species richness for 500 repeats of neutral_time_series_speciation, initial community size 100")
legend(50,
100,
legend = titles,
col = 1:2,
lty = 1:4)
lines(CI_upper_max)
lines(CI_lower_max)
lines(CI_upper_min, col = "red")
lines(CI_lower_min, col = "red")
}
challenge_A()
