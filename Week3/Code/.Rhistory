}
Tree.Heights.m = mapply(TreeHeight, MyData$Distance.m, MyData$Angle.degrees)
tmp = cbind(MyData,Tree.Heights.m)
write.csv(tmp, "../Results/TreeHts.csv")
MyData = read.csv("../Data/trees.csv")
MyFunction <- function(Arg1, Arg2) {
print(paste("Argument", as.character(Arg1), "is a", class(Arg1)))
print(paste("Argument", as.character(Arg2), "is a", class(Arg2)))
return(c(Arg1,Arg2))
}
MyFunction(1,2)
MyFunction("Bob","Geoff")
# Runs the stochastic (with gaussian fluctuations) Ricker Eqn .
set.seed(1)
rm(list=ls())
stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (pop in 1:length(p0)) #loop through the populations
{
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,pop]<-N[yr-1,pop]*exp(r*(1-N[yr-1,pop]/K)+rnorm(1,0,sigma))
}
}
return(N)
}
print("non vectorized system time is")
print(system.time(res1 <- stochrick()))
# Now write another code called stochrickvect that vectorizes the above
# to the extent possible, with improved performance:
rm(list=ls())
stochricknew<-function(p0=runif(1000,.5,1.5),numyears=100, r=1.2, K=1, sigma=0.2){
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (yr in 2:numyears) {
N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K))+rnorm(length(p0), 0, sigma)
}
return(N)
}
# Now write another code called stochrickvect that vectorizes the above
# to the extent possible, with improved performance:
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2 <- stochricknew()))
set.seed(1)
rm(list=ls())
stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (pop in 1:length(p0)) #loop through the populations
{
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,pop]<-N[yr-1,pop]*exp(r*(1-N[yr-1,pop]/K)+rnorm(1,0,sigma))
}
}
return(N)
}
print("non vectorized system time is")
print(system.time(res1 <- stochrick()))
Exponential <- function (N0 = 1, r =1, generations = 10){
N <- rep(NA, generations)
N[1] <-N0
for (t in 2:generations) {
N[t] <- N[t-1]*exp(r)
browser()
}
return (N)
}
plot(Exponential(), type = "1", main = "Exponential growth")
MyFuncn
plot(Exponential(), type = "1", main = "Exponential growth")
N
N
N
N
N
plot(Exponential(), type = "1", main = "Exponential growth")
?plot
Exponential <- function (N0 = 1, r =1, generations = 10){
N <- rep(NA, generations)
N[1] <-N0
for (t in 2:generations) {
N[t] <- N[t-1]*exp(r)
browser()
}
return (N)
}
plot(Exponential(), type = "l", main = "Exponential growth")
stochricknew<-function(p0=runif(1000,.5,1.5),numyears=100, r=1.2, K=1, sigma=0.2){
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (yr in 2:numyears) {
N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K))+rnorm(length(p0), 0, sigma)
}
return(N)
}
# Now write another code called stochrickvect that vectorizes the above
# to the extent possible, with improved performance:
MyMatrix =  stochricknew
# print("Vectorized Stochastic Ricker takes:")
print(system.time(stochrick()))
M = matrix(runif(1000000), 1000,1000)
SumAllElements =  function(M) {
Dimensions = dim(M)
Tot = 0
for (i in 1:Dimensions[1]){
for (j in 1:Dimensions[2]){
Tot = Tot + M[i,j]
}
}
return(Tot)
}
print(system.time((SumAllElements(M))))
print(system.time(sum(M)))
rm(list = ls())
library(stats) # for plot.ts
library(ggplot2)
library(pracma) # for movavg
gra
load("../Data/KeyWestAnnualMeanTemperature.RData")
Years = ats[[1]]
Temps = ats[[2]]
MyData = as.data.frame(cbind(Years,Temps))
return(MyData)
load("../Data/KeyWestAnnualMeanTemperature.RData")
setwd("~/Documents/CMEECourseWork/Week3/Code")
load("../Data/KeyWestAnnualMeanTemperature.RData")
Years = ats[[1]]
Temps = ats[[2]]
autocorr = acf(Temps,1)
autocorr
autocorr[1]
autocorr[[1]]
autocorr[[1]][1]
autocorr[[1]][2]
autocorr = acf(Temps,1)[[1]][2]
for (i in 1:1000){
acfs[i] = acf(sample(Temps,100))[[1]][2]
}
acfs = vector("numeric",1000)
acfs = vector("numeric",1000)
for (i in 1:1000){
acfs[i] = acf(sample(Temps,100))[[1]][2]
}
for (i in 1:1000){
acfs[i] = acf(sample(Temps,100))[[1]][2]
}
acfs
library(dplyr)
install.packages("dplyr")
library(dplyr)
library(dplyr)
?apply
apply
?apply
acfrandom = apply(Temps, sample(100))
acfrandom = apply(Temps, sample, arg2 = 100)
acfrandom = apply(Temps, sample, arg1=100)
acfrandom = lapply(Temps, sample, arg1=100)
acfrandom = lapply(Temps, sample, arg2=100)
acfrandom = lapply(Temps, sample, arg2=100)
acfrandom = lapply(Temps, 1,sample, arg2=100)
acfrandom = apply(Temps, 1,sample, arg2=100)
acfrandom = apply(Temps, 1,sample, arg1=100)
Temps %>% sample(.,100) %>% acf(.,1)
library(dplyr)
install.packages("Rcpp",  dependencies = TRUE, repos = "http://cran.us.r-project.org")
install.packages("Rcpp", dependencies = TRUE, repos = "http://cran.us.r-project.org")
library(dplyr)
Temps %>% sample(.,100) %>% acf(.,1)
for (i in 1:1000){
acfs2[i] <- Temps %>% sample(.,100) %>% acf(.,1)
}
acfs2 =vector("numeric",1000)
for (i in 1:1000){
acfs2[i] <- Temps %>% sample(.,100) %>% acf(.,1)
}
View(acfs2)
typeof(acf2AR())
typeof(acfs2)
acfs[[3]]
acfs[[[1]]]
acrfs[[2]]
acfs2[[2]]
acfs2[[2]][2]
slice(acfs2.data,2)
?slice
str(acfs2)
acfs2 =vector("numeric",1000)
for (i in 1:1000){
acfs2[i] <- Temps %>% sample(.,100) %>% acf(.,1)[[1]][2]
}
for (i in 1:1000){
acfs2[i] <- Temps %>% sample(.,100) %>% acf(.,1)[[1]][2]
}
for (i in 1:1000){
acfs2[i] <- Temps %>% sample(.,100) %>% acf(.,1)
}
x = acfs2[,2]
x = acfs2[[,2]]
str(acfs2)
?gather
library(tidyr)
?gather
head(acfs2)
acfs2 =vector("numeric",1000)
for (i in 1:1000){
acfs2[i] <- Temps %>% sample(.,100) %>% (acf(.,1))[[1]][2]
}
acfs[[2]][[2]]
acfs[[2]][2]
acfs[[2]][3]
acfs[[1]][2]
acfs2[[2]][2]
acfs2[[1]][2]
acfs2
acfs2 =vector("numeric",1000)
for (i in 1:1000){
acfs2[i] <- Temps %>% sample(.,100) %>% (acf(.,1))
}
acfs2 =vector("numeric",1000)
for (i in 1:1000){
acfs2[i] <- Temps %>% sample(.,100) %>% acf(.,1)
}
unlist(acfs2)
x = unlist(acfs)[2]
x
x = unlist(acfs)[,2]
x = unlist(acfs)[[,2]]
typeof(x)
x
x
x = unlist(acfs2)
typeof(x)
head(x)
x[1]
x[3]
Y = X %>% remove(c(FALSE,TRUE))
Y = X %>% remove(c(FALSE,TRUE))
Y = x %>% remove(c(FALSE,TRUE))
Y = remove(x,c(FALSE,TRUE))
Y = x %>% remove[c(FALSE,TRUE)]
?remove
Y = remove(list = x,c(FALSE,TRUE)
)
Y = x[c(FALSE,TRUE)]
acfs2 =vector("numeric",1000)
for (i in 1:1000){
acfs2[i] <- Temps %>% sample(.,100) %>% acf(.,1) %>% .[c(FALSE,TRUE)]
}
acfs2
acfs2 =vector("numeric",1000)
for (i in 1:1000){
acfs2[i] <- Temps %>% sample(.,100) %>% acf(.,1)
}
acfs2 =vector("numeric",1000)
for (i in 1:1000){
acfs2[i] <- Temps %>% sample(.,100) %>% acf(.,1)
}
acfs2 = unlist(acfs2[c(FALSE,TRUE)])
rm(list = ls())
library(stats) # for plot.ts
library(ggplot2)
library(pracma) # for movavg
# get the data
load("../Data/KeyWestAnnualMeanTemperature.RData")
Years = ats[[1]]
Temps = ats[[2]]
MyData = as.data.frame(cbind(Years,Temps))
raphics.off()
plot.ts(MyData$Temps)
#plot terms with lag of 1 to 4 years against each other M Crawley p787
par(mfrow = c(2,2))
sapply(1:4, function(x) plot(MyData$Temps[-c(100:(100-x+1))], MyData$Temps[-c(1:x)]))
#autocorrelation coef is Sum(Y[i+1]-AveY)(Y[i] -AveY)/sum(sqr(Y[i]-AveY))
# calculate sum[(Yi+1 - ave)(Yi - ave)] -- numerator of autocorr coef
#Calc_numerator = function(avector){
num = vector("numeric",99)
for (i in seq_along((Temps))) {
if (i <100) {
num[i] = as.vector( Temps[i+1] - mean(Temps) ) * ( Temps[i] - mean(Temps) )
}
else
totalnum = sum(num)}
#Calc_denom = function(avector){
#  calcuate sum[(Yi - ave)^2] -- denom of auto corr coef
denom = vector("numeric",99)
for (i in seq_along((Temps))) {
if (i <100) {
denom[i] = as.vector(( Temps[i] - mean(Temps) )^2)
}
else
totaldenom = sum(denom)}
#Calc_acf = function(avector){
autocorrcoef = totalnum/totaldenom
print("autocorrelatoin coefficient for lag 1 is ")
print(autocorrcoef)
#generate 1000 acf from random sampling of Temps
acfs = vector("numeric",1000)
for (j in 1:1000){
num = vector("numeric",99)
denom = vector("numeric",99)
for (i in seq_along((Temps))) {
RTemp = sample(Temps,100)
if (i <100) {
num[i] = as.vector( RTemp[i+1] - mean(RTemp) ) * (RTemp[i] - mean(RTemp) )
denom[i] = as.vector(( RTemp[i] - mean(RTemp) )^2)
}
else
totalnum = sum(num)
totaldenom = sum(denom)
}
acfs[j] = totalnum/totaldenom
}
#Calc_p_Value = function(avector,avalue){
p = length(acfs[acfs > autocorrcoef])/1000
print("p value for autocorrelation coeffice=ient of lag 1 is ")
print(p)
#Since p value indicates correlation between points, lets look at moving average
#and plot a trend line
ma = movavg(MyData$Temps, 2, "s") # simple moving average with 2 points
MyData = as.data.frame(cbind(MyData,ma)) # need a dataframe for ggplot
lm = summary(lm(MyData$ma ~ MyData$Years, MyData)) #a linear model of moving averages
ggplot(MyData, aes(y = MyData$ma, x = MyData$Years , colour  = abs(lm$residuals)))+
geom_point()+
geom_abline(intercept = lm$coefficients[1][1],
slope = lm$coefficients[2][1],
colour = "red")
rm(list = ls())
library(stats) # for plot.ts
library(ggplot2)
library(pracma) # for movavg
# get the data and make two vectors coz easier for loops
load("../Data/KeyWestAnnualMeanTemperature.RData")
Years = ats[[1]]
Temps = ats[[2]]
MyData = as.data.frame(cbind(Years,Temps))
#Examine = function(Data){
# plot simple time seriesgraphics.off()
pdf("../Results/TAutocorrtimeseries2.pdf")
plot.ts(MyData$Temps)
#plot terms with lag of 1 to 4 years against each other M Crawley p787
dev.off()
pdf("../Results/TAutocorrtimeseries2.pdf")
par(mfrow = c(2,2))
sapply(1:4, function(x) plot(MyData$Temps[-c(100:(100-x+1))], MyData$Temps[-c(1:x)]))
dev.off()
#autocorrelation coef is Sum(Y[i+1]-AveY)(Y[i] -AveY)/sum(sqr(Y[i]-AveY))
# calculate sum[(Yi+1 - ave)(Yi - ave)] -- numerator of autocorr coef
#Calc_numerator = function(avector){
num = vector("numeric",99)
for (i in seq_along((Temps))) {
if (i <100) {
num[i] = as.vector( Temps[i+1] - mean(Temps) ) * ( Temps[i] - mean(Temps) )
}
else
totalnum = sum(num)}
#Calc_denom = function(avector){
#  calcuate sum[(Yi - ave)^2] -- denom of auto corr coef
denom = vector("numeric",99)
for (i in seq_along((Temps))) {
if (i <100) {
denom[i] = as.vector(( Temps[i] - mean(Temps) )^2)
}
else
totaldenom = sum(denom)}
#Calc_acf = function(avector){
autocorrcoef = totalnum/totaldenom
print("autocorrelatoin coefficient for lag 1 is ")
print(autocorrcoef)
#generate 1000 acf from random sampling of Temps
acfs = vector("numeric",1000)
for (j in 1:1000){
num = vector("numeric",99)
denom = vector("numeric",99)
for (i in seq_along((Temps))) {
RTemp = sample(Temps,100)
if (i <100) {
num[i] = as.vector( RTemp[i+1] - mean(RTemp) ) * (RTemp[i] - mean(RTemp) )
denom[i] = as.vector(( RTemp[i] - mean(RTemp) )^2)
}
else
totalnum = sum(num)
totaldenom = sum(denom)
}
acfs[j] = totalnum/totaldenom
}
#Calc_p_Value = function(avector,avalue){
p = length(acfs[acfs > autocorrcoef])/1000
print("p value for autocorrelation coeffice=ient of lag 1 is ")
print(p)
g = open('../Results/pvalue.csv', 'wb')
write.csv(p,g)
pdf("../Results/TAutocorrtimeseries1.pdf")
plot.ts(MyData$Temps)
#plot terms with lag of 1 to 4 years against each other M Crawley p787
dev.off()
pdf("../Results/TAutocorrtimeseries2.pdf")
par(mfrow = c(2,2))
sapply(1:4, function(x) plot(MyData$Temps[-c(100:(100-x+1))], MyData$Temps[-c(1:x)]))
dev.off()
#autocorrelatio
p = length(acfs[acfs > autocorrcoef])/1000
print("p value for autocorrelation coeffice=ient of lag 1 is ")
print(p)
g = open('../Results/pvalue.csv', 'wb')
write.csv(p,g)
g = open('../Results/pvalue.csv', 'wb')
g.write.csv(p)
g = open('../Results/pvalue.csv', 'wb')
g.write(p)
g = open('../Results/pvalue.txt', 'wb')
g.write(p)
?write
write(p,'../Results/pvalue.txt' )
message = "p value for autocorrelation coeffice=ient of lag 1 is "
output = message + p
output = c(message,p)
write(output,'../Results/pvalue.txt' )
ma = movavg(MyData$Temps, 2, "s") # simple moving average with 2 points
MyData = as.data.frame(cbind(MyData,ma)) # need a dataframe for ggplot
lm = summary(lm(MyData$ma ~ MyData$Years, MyData)) #a linear model of moving averages
pdf("../Results/TAutocorrmovingavg.pdf")
ggplot(MyData, aes(y = MyData$ma, x = MyData$Years , colour  = abs(lm$residuals)))+
geom_point()+
geom_abline(intercept = lm$coefficients[1][1],
slope = lm$coefficients[2][1],
colour = "red")
dev.off()
?plot.ts
plot.ts(MyData$Temps, title(main = "Time series of temperature data for KeyWest 1900 - 2000", xlab = "date"))
plot.ts(MyData$Temps, title(main = "Time series of temperature data for KeyWest 1900 - 2000", xlab = "date", ylab = "Temperature"))
dev.off()
plot.ts(MyData$Temps, title(main = "Time series of temperature data for KeyWest 1900 - 2000", xlab = "date", ylab = "Temperature"))
plot.ts(MyData$Temps, title(main = "Time series of temperature data for KeyWest 1900 - 2000", xlab = "date", ylab = "Temperature"))
dev.off()
plot.ts(MyData$Temps, title(main = "Time series of temperature data for KeyWest 1900 - 2000", xlab = "date", ylab = "Temperature"))
plot.ts(MyData$Temps); title(main = "Time series of temperature data for KeyWest 1900 - 2000", xlab = "date", ylab = "Temperature")
plot.ts(MyData$Temps, xy.labels = FALSE); title(main = "Time series of temperature data for KeyWest 1900 - 2000", xlab = "date", ylab = "Temperature")
dev.off()
plot.ts(MyData$Temps, xy.labels = FALSE);
title(main = "Time series of temperature data for KeyWest 1900 - 2000", xlab = "date", ylab = "Temperature")
plot(MyData$Temps, xy.labels = FALSE);
title(main = "Time series of temperature data for KeyWest 1900 - 2000", xlab = "date", ylab = "Temperature")
dev.off()
lm = summary(lm(MyData$ma ~ MyData$Years, MyData)) #a linear model of moving averages
pdf("../Results/TAutocorrmovingavg.pdf")
ggplot(MyData, aes(y = MyData$ma, x = MyData$Years , colour  = abs(lm$residuals)))+
geom_point()+
geom_abline(intercept = lm$coefficients[1][1],
slope = lm$coefficients[2][1],
colour = "red")
ggplot(MyData, aes(y = MyData$ma, x = MyData$Years , colour  = abs(lm$residuals)))+
geom_point()+
geom_abline(intercept = lm$coefficients[1][1],
slope = lm$coefficients[2][1],
colour = "red")
ggplot(MyData, aes(y = MyData$ma, x = MyData$Years , colour  = abs(lm$residuals)))+
geom_point()+
geom_abline(intercept = lm$coefficients[1][1],
slope = lm$coefficients[2][1],
colour = "red")
dev.off()
graphics.off()
ggplot(MyData, aes(y = MyData$ma, x = MyData$Years , colour  = abs(lm$residuals)))+
geom_point()+
geom_abline(intercept = lm$coefficients[1][1],
slope = lm$coefficients[2][1],
colour = "red")
dev.off()
ggplot(MyData, aes(y = MyData$ma, x = MyData$Years , colour  = abs(lm$residuals)))+
geom_point()+
labs(x = "Years", title = "Scatterplot of 2 point moving average and linear fit", y = "Moving Average")+
geom_abline(intercept = lm$coefficients[1][1],
slope = lm$coefficients[2][1],
colour = "red")
pdf("../Results/TAutocorrmovingavg.pdf")
ggplot(MyData, aes(y = MyData$ma, x = MyData$Years , colour  = abs(lm$residuals)))+
geom_point()+
labs(x = "Years", title = "Scatterplot of 2 point moving average and linear fit", y = "Moving Average")+
geom_abline(intercept = lm$coefficients[1][1],
slope = lm$coefficients[2][1],
colour = "red")
dev.off()
ggplot(MyData$Temps, aes(x = MyData$Years, y = MyData$Temps))+
labs(Title = "Time series of temperature data for KeyWest 1900 - 2000", x = "date", y = "Temperature")+
geom_step()
ggplot(MyData$Temps, aes(x = MyData$Years, y = MyData$Temps))+
labs(Title = "Time series of temperature data for KeyWest 1900 - 2000", x = "date", y = "Temperature")+
geom_step()
ggplot(MyData$Temps, aes(x = MyData$Years, y = MyData$Temps))+
labs(Title = "Time series of temperature data for KeyWest 1900 - 2000", x = "date", y = "Temperature")+
geom_point()
ggplot(MyData, aes(x = MyData$Years, y = MyData$Temps))+
labs(Title = "Time series of temperature data for KeyWest 1900 - 2000", x = "date", y = "Temperature")+
geom_point()
ggplot(MyData, aes(x = MyData$Years, y = MyData$Temps))+
labs(Title = "Time series of temperature data for KeyWest 1900 - 2000", x = "date", y = "Temperature")+
geom_line()
ggplot(MyData, aes(x = MyData$Years, y = MyData$Temps))+
labs(title = "Time series of temperature data for KeyWest 1900 - 2000", x = "date", y = "Temperature")+
geom_line()
pdf("../Results/TAutocorrtimeseries1.pdf")
ggplot(MyData, aes(x = MyData$Years, y = MyData$Temps))+
labs(title = "Time series of temperature data for KeyWest 1900 - 2000", x = "date", y = "Temperature")+
geom_line()
dev.off()
