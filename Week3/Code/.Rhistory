File =  "test.csv"
path = paste("../Data", File, sep = "/")
strsplit("File", "\\.")[[1]]
InputFileName = "test.csv"
pathname = paste("../Data",InputFileName, sep = "/")
MyData = read.csv(pathname)
tmp = strsplit("InputFilename", "\\.")[[1]]
tmpout = paste(tmp,"treeheights", sep = "_")
outfile = paste("../Results",tmpout, sep = "/")
tmp = strsplit(InputFileName, "\\.")[[1]]
tmp = strsplit(InputFileName, "\\.")[[1]]
tmpout = paste(tmp,"treeheights", sep = "_")
outfile = paste("../Results",tmpout, sep = "/")
tmp = strsplit(InputFileName, "\\.")[[1]]
tmp[[1]]
tmp = (strsplit(InputFileName, "\\.")[[1]])
tmp = strsplit(InputFileName, "\\.")[[1]]
tmpout = paste(tmp[[1]],"treeheights", sep = "_")
outfile = paste("../Results",tmpout, sep = "/")
tmp = strsplit(InputFileName, "\\.")
tmpout = paste(tmp[[1]],"treeheights", sep = "_")
outfile = paste("../Results",tmpout, sep = "/")
tmp = strsplit(InputFileName, "\\.")[[1]]
tmpout = paste(tmp[[1]],"treeheights", sep = "_")
outfile = paste("../Results",tmpout, sep = "/")
?paste
?runif
M = matrix(runif(1000000), 1000,1000)
SumAllElements =  function(M) {
Dimensions = dim(M)
Tot = 0
for (i in 1:Dimensions[1]){
for (j in 1:Dimensions[2]){
Tot = Tot + M[i,j]
}
}
return(Tot)
}
print(system.time((SumAllElements(M))))
print(system.time(sum(M)))
rm(list=ls())
M = matrix(rnorm(100),10,10)
R1 = rowMeans(M)
R2 = apply(M,1,mea
R2 = apply(M,1,mean)
R2 = apply(M,1,mean)
R1 = rowMeans(M)
R2 = apply(M,1,mean)
C1 = colMeans(M)
C2 = apply(M,2,mean)
SomeOperation = function(v) {
if sum(v) > 0
return (v*100)
}
return(v)
M = matrix(rnorm(100),10,10)
print(apply(M, 1, SomeOperation)
SomeOperation = function(v) {
if (sum(v) > 0)
return (v*100)
}
return(v)
M = matrix(rnorm(100),10,10)
print(apply(M, 1, SomeOperation))
SomeOperation = function(v) {
if (sum(v) > 0)
return (v*100)
}
return(v)
M = matrix(rnorm(100),10,10)
print(apply(M, 1, SomeOperation))
x = 1:20
y = factor(rep(letters[1:5], each = 4))
y
tapply(x,y,sum)
attach(iris)
print(iris)
by(iris[,1:2], iris$Species, colMeans)
by(iris[,1:2], iris$Petal.Width, colMeans)
require(dplyr)
install.packages("dplyr")
library(dplyr)
dplyr::tbl_df(iris)
dplyr::glimpse(iris)
utils::View(iris)
dplyr::filter(iris, Sepal.Length >7)
dplyr::slice(iris, 10:15)
?tibble
args <- commandArgs(TRUE)
InputFileName <- as.character(args[1])
#paste the input filename onto the relative path
pathname = paste("../Data",InputFileName, sep = "/")
MyData = read.csv(pathname)
#This is the heights calcultion
TreeHeight = function(distance, angle) {
radians =  angle*pi/180
height = distance * tan(radians)
print(height)
}
#strip ,csv off input file and create output fileneme
tmp = strsplit(InputFileName, "\\.")[[1]]
tmpout = paste(tmp[[1]],"treeheights", sep = "_")
tmpout2 = paste(tmpout,".csv")
outfile = paste("../Results",tmpout2, sep = "/")
Tree.Heights.m = mapply(TreeHeight, MyData[2], MyData[3])
tempdata = cbind(MyData,Tree.Heights.m)
write.csv(tmpdata, outfile)
args <- commandArgs(TRUE)
InputFileName <- as.character(args[1])
#paste the input filename onto the relative path
pathname = paste("../Data",InputFileName, sep = "/")
MyData = read.csv(pathname)
#This is the heights calcultion
TreeHeight = function(distance, angle) {
radians =  angle*pi/180
height = distance * tan(radians)
print(height)
}
#strip ,csv off input file and create output fileneme
tmp = strsplit(InputFileName, "\\.")[[1]]
tmpout = paste(tmp[[1]],"treeheights", sep = "_")
tmpout2 = paste(tmpout,".csv")
outfile = paste("../Results",tmpout2, sep = "/")
Tree.Heights.m = mapply(TreeHeight, MyData[2], MyData[3])
tempdata = cbind(MyData,Tree.Heights.m)
write.csv(tempdata, outfile)
args <- commandArgs(TRUE)
InputFileName <- as.character(args[1])
#paste the input filename onto the relative path
pathname = paste("../Data",InputFileName, sep = "/")
MyData = read.csv(pathname)
#This is the heights calcultion
TreeHeight = function(distance, angle) {
radians =  angle*pi/180
height = distance * tan(radians)
print(height)
}
#strip ,csv off input file and create output fileneme
tmp = strsplit(InputFileName, "\\.")[[1]]
tmpout = paste(tmp[[1]],"treeheights", sep = "_")
tmpout2 = paste(tmpout,".csv")
outfile = paste("../Results",tmpout2, sep = "/")
Tree.Heights.m = mapply(TreeHeight, MyData[2], MyData[3])
tempdata = cbind(MyData,Tree.Heights.m)
write.csv(tempdata, outfile
)
Tree.Heights.m = mapply(TreeHeight, MyData[2], MyData[3])
tempdata = cbind(MyData,Tree.Heights.m
)
?mapply
MyData = read.csv("../Data/trees.csv")
TreeHeight = function(distance, angle) {
radians =  angle*pi/180
height = distance * tan(radians)
print(height)
}
Tree.Heights.m = mapply(TreeHeight, MyData$Distance.m, MyData$Angle.degrees)
tmp = cbind(MyData,Tree.Heights.m)
write.csv(tmp, "../Results/TreeHts.csv")
MyData = read.csv("../Data/trees.csv")
MyData = read.csv("../Data/trees.csv")
TreeHeight = function(distance, angle) {
radians =  angle*pi/180
height = distance * tan(radians)
print(height)
}
Tree.Heights.m = mapply(TreeHeight, MyData$Distance.m, MyData$Angle.degrees)
tmp = cbind(MyData,Tree.Heights.m)
write.csv(tmp, "../Results/TreeHts.csv")
MyData = read.csv("../Data/trees.csv")
MyFunction <- function(Arg1, Arg2) {
print(paste("Argument", as.character(Arg1), "is a", class(Arg1)))
print(paste("Argument", as.character(Arg2), "is a", class(Arg2)))
return(c(Arg1,Arg2))
}
MyFunction(1,2)
MyFunction("Bob","Geoff")
# Runs the stochastic (with gaussian fluctuations) Ricker Eqn .
set.seed(1)
rm(list=ls())
stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (pop in 1:length(p0)) #loop through the populations
{
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,pop]<-N[yr-1,pop]*exp(r*(1-N[yr-1,pop]/K)+rnorm(1,0,sigma))
}
}
return(N)
}
print("non vectorized system time is")
print(system.time(res1 <- stochrick()))
# Now write another code called stochrickvect that vectorizes the above
# to the extent possible, with improved performance:
rm(list=ls())
stochricknew<-function(p0=runif(1000,.5,1.5),numyears=100, r=1.2, K=1, sigma=0.2){
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (yr in 2:numyears) {
N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K))+rnorm(length(p0), 0, sigma)
}
return(N)
}
# Now write another code called stochrickvect that vectorizes the above
# to the extent possible, with improved performance:
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2 <- stochricknew()))
set.seed(1)
rm(list=ls())
stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (pop in 1:length(p0)) #loop through the populations
{
for (yr in 2:numyears) #for each pop, loop through the years
{
N[yr,pop]<-N[yr-1,pop]*exp(r*(1-N[yr-1,pop]/K)+rnorm(1,0,sigma))
}
}
return(N)
}
print("non vectorized system time is")
print(system.time(res1 <- stochrick()))
Exponential <- function (N0 = 1, r =1, generations = 10){
N <- rep(NA, generations)
N[1] <-N0
for (t in 2:generations) {
N[t] <- N[t-1]*exp(r)
browser()
}
return (N)
}
plot(Exponential(), type = "1", main = "Exponential growth")
MyFuncn
plot(Exponential(), type = "1", main = "Exponential growth")
N
N
N
N
N
plot(Exponential(), type = "1", main = "Exponential growth")
?plot
Exponential <- function (N0 = 1, r =1, generations = 10){
N <- rep(NA, generations)
N[1] <-N0
for (t in 2:generations) {
N[t] <- N[t-1]*exp(r)
browser()
}
return (N)
}
plot(Exponential(), type = "l", main = "Exponential growth")
stochricknew<-function(p0=runif(1000,.5,1.5),numyears=100, r=1.2, K=1, sigma=0.2){
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (yr in 2:numyears) {
N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K))+rnorm(length(p0), 0, sigma)
}
return(N)
}
# Now write another code called stochrickvect that vectorizes the above
# to the extent possible, with improved performance:
MyMatrix =  stochricknew
# print("Vectorized Stochastic Ricker takes:")
print(system.time(stochrick()))
M = matrix(runif(1000000), 1000,1000)
SumAllElements =  function(M) {
Dimensions = dim(M)
Tot = 0
for (i in 1:Dimensions[1]){
for (j in 1:Dimensions[2]){
Tot = Tot + M[i,j]
}
}
return(Tot)
}
print(system.time((SumAllElements(M))))
print(system.time(sum(M)))
library(ggplot2)
SparrowsData = read.table("../Data/SparrowSize.txt", header = TRUE)
Winghist = ggplot(SparrowsData, aes(Wing))+
geom_histogram()
BodyMassHist = ggplot(SparrowsData, aes(Mass))+
geom_histogram()
BillHist = ggplot(SparrowsData, aes(Bill))+
geom_histogram()
MeanBill = mean(SparrowsData$Bill, na.rm = TRUE)
# Ex 7.15
a = TRUE
if (a ==TRUE){
print("a is TRUE")
} else {
print(" a is FALSE")
}
z =  runif(1)
if (z <= 0.5){
print("less than half")
}
for (i in 1:100){
j = i*i
print(paste(i,"squared is", j))
}
v = c("frog", "dog","mog", "hog")
for (animals in v){
print(paste("the animal is ", animal))
}
i = 0
while ( i < 100){
i = i+1
print(i^2)
}
Mydf = as.data.frame(read.csv("../Data/EcolArchives-E089-51-D1.csv"))
setwd("~/Documents/CMEECourseWork/Week3/Code")
Mydf = as.data.frame(read.csv("../Data/EcolArchives-E089-51-D1.csv"))
logsPredMass = log(Mydf$Predator.mass)
Mydf[["Predator.mass"]] = logsPredMass
logsPreyMass = log(Mydf$Prey.mass)
Mydf[["Prey.mass"]] = logsPreyMass
View(Mydf)
View(Mydf)
# Practical Chapter 9
#Using dplyr, but cant get dplyr to load anymore. hace removed and reinstalled Rcpp, changed file acces for Rcpp and reinstalled dplyr
#several times.
# so cant check this script anymore.
library(dplyr) # need for filter
library(ggplot2)
library(plyr) # need for count
#library(magrittr)
#library(tidyr)
#library(sqldf)
rm(list = ls())
Mydf = as.data.frame(read.csv("../Data/EcolArchives-E089-51-D1.csv"))
pdf("../Results/PP_Regress.pdf",  11.7, 8.3)
plot = ggplot(Mydf, aes(x = log(Prey.mass), y = log(Predator.mass) ) )+
geom_point(aes(col = Predator.lifestage), shape = 3)+
stat_smooth(method = "lm", aes(col = Predator.lifestage), fullrange = TRUE) +
facet_grid(Type.of.feeding.interaction ~ .)
print(plot)
dev.off()
# convert to g and log everything
l = length(Mydf$Prey.mass)
for (i in 1:l){
if (Mydf$Prey.mass.unit[i] == "mg") {
Mydf$Prey.mass[i] = Mydf$Prey.mass[i] * 1e-3
}
}
logsPredMass = log(Mydf$Predator.mass)
Mydf[["Predator.mass"]] = logsPredMass
logsPreyMass = log(Mydf$Prey.mass)
Mydf[["Prey.mass"]] = logsPreyMass
#models = Mydf %>%  filter(Type.of.feeding.interaction == "insectivorous") %>%  group_by(Predator.lifestage) %>%  do(lm(log(Predator.mass) ~ log(Prey.mass)))
#dplyr not loading - trouble with Rcpp, says need 2.17 - but can only install 2.13. they keep going to temp directory and cant unzip them. not sure its worth the bother
#redownlaoded again. dplyr working today
#means = Mydf %>% group_by(Type.of.feeding.interaction) %>% group_by(Predator.lifestage, add = TRUE) %>%   summarize(m = mean(Predator.mass)) #%>%  assign("bar", .)
#Modelspiped = Mydf %>% group_by(Type.of.feeding.interaction) %>% group_by(Predator.lifestage, add = TRUE) %>%  do(fits = lm(log(Predator.mass) ~ log(Prey.mass), data = . ))
# above pipe is fine - but need summary of data, and need to know what the model is fitting
#Start again using filters etc. Part of the issue is that I am trying to automate everything, as if I dont know what each grpup will throw out. To make
#program generic. Difficulty is that I then need to introduce separate functions to assess each subset created. For how many Lifestages for example.
#Wont continue with that for this exercise, but in future, I'd need to address that. Using key below to attach labesl to subsets etc.
convertoutput <-function(x){ # this makes output of summary look ok, otherwise nonsense when written to csv
res<-c(paste(as.character(summary(x)$call),collapse=" "),
x$coefficients[1],
x$coefficients[2],
length(x$model),
summary(x)$coefficients[2,2],
summary(x)$r.squared,
summary(x)$adj.r.squared,
summary(x)$fstatistic,
pf(summary(x)$fstatistic[1],summary(x)$fstatistic[2],summary(x)$fstatistic[3],lower.tail=FALSE))
names(res)<-c("call","intercept","slope","n","slope.SE","r.squared","Adj. r.squared",
"F-statistic","numdf","dendf","p.value")
return(res)}
keyFeedGroups = as.character(unique(Mydf$Type.of.feeding.interaction))
keyPredLifeStage = as.character(unique(Mydf$Predator.lifestage))
insectivors = filter(Mydf, Type.of.feeding.interaction == "insectivorous")
pred_pisc = filter(Mydf, Type.of.feeding.interaction ==  "predacious/piscivorous")
piscivorous =  filter(Mydf, Type.of.feeding.interaction ==  "piscivorous")
planktivorous = filter(Mydf, Type.of.feeding.interaction ==  "planktivorous")
predacious = filter(Mydf, Type.of.feeding.interaction ==  "predacious")
##how many lifestages in each subset above and what are they
get_LifeStages = function(dataframe){
LifeStages = as.character(unique(dataframe$Predator.lifestage))
}
get_numberLifeStages = function(dataframe){
No_Stages = sum(count(unique(dataframe$Predator.lifestage))$freq)
}
### how many predator life stages in each feed interaction
insectivorstages = get_LifeStages(insectivors)
pred_piscstages = get_LifeStages(pred_pisc)
piscivorousstages =  get_LifeStages(piscivorous)
planktivorousstages = get_LifeStages(planktivorous)
predaciousstages = get_LifeStages(predacious)
# need to loop for the number of stages times, over the stages to get the required models.
n = length(piscivorousstages)
for (i in 1:n){
#browser()
model = lm(piscivorous$Predator.mass ~ piscivorous$Prey.mass,
subset = (piscivorous$Predator.lifestage == piscivorousstages[i]))
title = c("predator life stage ", piscivorousstages[i], "piscivorous")
output = convertoutput(model)
fullout = rbind(title, output)
write.table( fullout,
file="../Results/PP_Regress.csv",
append = T,
sep=',',
row.names=T,
col.names=T )
}
#this gives an output, but its nasty to read. Spent 3 days on these. Need to move on fopr now. Going to try in python
print(insectivors)
n = length(insectivors)
for (i in 1:n){
#browser()
model = lm(insectivors$Predator.mass ~ insectivors$Prey.mass,
subset = (insectivors$Predator.lifestage == insectivorstages[i]))
title = c("predator life stage ", insectivorstages[i], "insectivorous")
output = convertoutput(model)
fullout = rbind(title, output)
write.table( fullout,
file="../Results/PP_Regress.csv",
append = T,
sep=',',
row.names=T,
col.names=T )
}
### next group### this should be a loop###
n = length(pred_piscstages)
for (i in 1:n){
#browser()
model = lm(pred_pisc$Predator.mass ~ pred_pisc$Prey.mass,
subset = (pred_pisc$Predator.lifestage == pred_piscstages[i]))
title = c("predator life stage ", pred_piscstages[i], "pred_piscivorous")
output = convertoutput(model)
fullout = rbind(title, output)
write.table( fullout,
file="../Results/PP_Regress.csv",
append = T,
sep=',',
row.names=T,
col.names=T )
}
n = length(predaciousstages)
for (i in 1:n){
#browser()
model = lm(predacious$Predator.mass ~ predacious$Prey.mass,
subset = (predacious$Predator.lifestage == predaciousstages[i]))
title = c("predator life stage ", predaciousstages[i], "pred_piscivorous")
output = convertoutput(model)
fullout = rbind(title, output)
write.table( fullout,
file="../Results/PP_Regress.csv",
append = T,
sep=',',
row.names=T,
col.names=T )
}
