Starting weekly assessment for Petra, Week2

Current Marks = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 12.46 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week1, Assessment, Week2, Week4, .git, Week3

Found the following files in parent directory: .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
**********************************************************************

README file missing, 1 pt deducted

Current Marks = 99

======================================================================
Looking for the weekly directories...

Found 4 weekly directories: Week1, Week2, Week3, Week4

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Data, Sandbox

Found the following files: README

Checking for readme file in weekly directory...

Found README in parent directory, named: README

Printing contents of README:
**********************************************************************


cfexercises_flow

To make this a module, and all the functions callable, I added the if (__name__ == "__main__"):bit on the bottom, imported sys and then created a main function tht would run the script.

dictionary_py
I found 2 ways of tackling this, in one I created the keys and added the values in a for loop, in the other, super neat version, I used defaultdic. You tell it that the values are a list, then it works through the list of tuples assigning accordingly.


Chapter 5 Extra Credit - Matching fasta files.

I started this program from scratch in order to learn and consolidate this weeks python.

I created a function to read the fasta file, but the commas, spaces and top two lines had to be removed. I then turned the file into a string

I used the same idea as align_seq to make the longest chain into "longest"

To mimic moving the shorter seq along the longer I removed the first element from the longest chain in a for loop.

I then looked at matches between the two chains using a numpy array.

Since the numpy array equality required arrays of the same size I had to chop the end off the longest chain in incrementally smaller amounts.

Missing Oaks.

The relative paths were wrong, only ../ needed not ../../
I changed the code so that "quercus" could be input (length string = 7) or quercus with a space or spelling errors such as quercuss (length of string not 7)

I am guessing there would by a nicer way to do this, but couldnt find it.
The doctest output was confusing because although I got failed messages, the tests also said passed, ok. I reran the code in a different window, and it worked. I could see that each tree test had passed, so I am not sure what the failed messages were.

This week I created a bash script to run all the scripts to see if that would a) make sure I had completed all the scripts b) throw up any errors. It all ran OK. 



**********************************************************************

Results directory missing!

Found 21 code files: lc2.py, boilerplate.py, basic_csv.py, test_oaks.py, dictionary.py, LV1.py, debugme.py, scope.py, tuple.py, profilename.py, basic_io.py, lc1.py, oaks.py, loops.py, using_name.py, cfexercises.py, align_seqs.py, sysargv.py, align_seqs_fasta.py, control_flow.py, test_control_flow.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""Chapter 5 Practicals, modify lc2.py, Petra Guy
	Writing list comprehensions and for loops to extract elements from a list"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports

#constants

#functions



# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.
 
# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS


#Here are the list comprehension methods. In the first, since we need each tuple
#element its just x for x in rainfall.
#For the second only want the first item in each element, hence x[0] for x in rainfall

rainfall_over100mm = [x for x in rainfall if x[1] > 100.0]
print rainfall_over100mm

months_less50mm = [x[0] for x in rainfall if x[1] < 50]
print months_less50mm

#The above with for loops

rain_over100mm = list()
for months in rainfall:
	if (months[1] > 100):
		rain_over100mm.append(months[0])
print rain_over100mm


**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']
['JAN', 'FEB', 'AUG', 'NOV', 'DEC']

**********************************************************************

Code ran without errors

Time consumed = 0.01263s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""Program description Boilerplate/Template"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports

import sys

#constants

#functions


def main(argv):
		print 'This is a boilerplate'
		return 0
		
if (__name__ == "__main__"):
		status = main(sys.argv)
		sys.exit(status)

**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.01060s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""5.8 Reading csv files"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports

import csv

#read a csv file and append stuff to each row

f = open('../Data/testcsv.csv','rb')

csvread = csv.reader(f)
temp = []
for row in csvread:
		temp.append(tuple(row))
		print row
		print "The species is", row[0]
f.close()

#write only the species to another file

f = open('../Data/testcsv.csv', 'rb')
g = open('../Results/bodymass.csv', 'wb')

csvread = csv.reader(f)
csvwrite = csv.writer(g)
for row in csvread:
		print row
		csvwrite.writerow([row[0], row[4]])
f.close()
g.close()

**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagasc
**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "basic_csv.py", line 27, in <module>
    g = open('../Results/bodymass.csv', 'wb')
IOError: [Errno 2] No such file or directory: '../Results/bodymass.csv'

======================================================================
Inspecting script file test_oaks.py...

File contents are:
**********************************************************************
import csv
import sys
import pdb
import doctest

#Define function
def is_an_oak(name):
	
	""" Returns True if name is starts with 'quercus '
	
	>>> is_an_oak('quercus')
	True
    
	>>> is_an_oak('Pinus sylvestris')
	False
		
	>>> is_an_oak('Quercus')
	True
	
	>>> is_an_oak('Quercustard')
	False
	"""
	#return name.lower().startswith('quercus ') #The space after the s ensures only quercus is matched
	#I added this bit to catch things with no space	
	 
	if (len(name) ==7):
		return name.lower() == ("quercus") # this bit tests the oakness
	else:								   # if there's no space
		return name.lower().startswith('quercus ')  #  with the space
		
print(is_an_oak.__doc__)

def main(argv): 
    f = open('../Data/TestOaksData.csv','rb')
    g = open('../Results/JustOaksData.csv','wb')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    oaks = set()
    for row in taxa:
        print row
        print "The genus is", row[0]
        if is_an_oak(row[0]):
            print row[0]
            print 'FOUND AN OAK!'
            print " "
            csvwrite.writerow([row[0], row[1]])    
    
    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)

doctest.testmod()
**********************************************************************

Testing test_oaks.py...

test_oaks.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
 Returns True if name is starts with 'quercus '
	
	>>> is_an_oak('quercus')
	True
    
	>>> is_an_oak('Pinus sylvestris')
	False
		
	>>> is_an_oak('Quercus')
	True
	
	>>> is_an_oak('Quercustard')
	False
	

**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "test_oaks.py", line 51, in <module>
    status = main(sys.argv)
  File "test_oaks.py", line 35, in main
    g = open('../Results/JustOaksData.csv','wb')
IOError: [Errno 2] No such file or directory: '../Results/JustOaksData.csv'

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a short python script to populate a dictionary called taxa_dic 
# derived from  taxa so that it maps order names to sets of taxa. 
# E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. 

# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS
	
"""Create a dictionary from the taxa list of tuples using two methods"""

#This first method creates a set of keys. Creating a set ensure the elements are unique

#keys = set([v for k, v in taxa])

#mydict = {}
#loop thru keys assigning each species if in taxa its family is equal to the key
#for key in keys:
#	mydict[key] = []
#	for item in taxa:
#		if item[1] == key:
#			mydict[key].append(item[0])
#print mydict 


#But this method using collections is super neat
#defaultdict(list) says that the values for each key are a list

from collections import defaultdict


mydict2 = defaultdict(list)
for k, v in taxa:
	mydict2[v].append(k)
	
print mydict2
        
**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
defaultdict(<type 'list'>, {'Rodentia': ['Gerbillus henleyi', 'Peromyscus crinitus', 'Mus domesticus', 'Cleithrionomys rutilus'], 'Afrosoricida': ['Microgale dobsoni', 'Microgale talazaci'], 'Chiroptera': ['Myotis lucifugus'], 'Carnivora': ['Lyacon pictus', 'Arctocephalus gazella', 'Canis lupus']})

**********************************************************************

Code ran without errors

Time consumed = 0.01383s

======================================================================
Inspecting script file LV1.py...

File contents are:
**********************************************************************
""" The typical Lotka-Volterra Model simulated using scipy """

import scipy as sc 
import scipy.integrate as integrate
import pylab as p #Contains matplotlib for plotting

# import matplotlip.pylab as p #Some people might need to do this

def dR_dt(pops, t=0):
    """ Returns the growth rate of predator and prey populations at any 
    given time step """
    
    R = pops[0]
    C = pops[1]
    dRdt = r*R - a*R*C 
    dydt = -z*C + e*a*R*C
    
    return sc.array([dRdt, dydt])

# Define parameters:
r = 1. # Resource growth rate
a = 0.1 # Consumer search rate (determines consumption rate) 
z = 1.5 # Consumer mortality rate
e = 0.75 # Consumer production efficiency

# Now define time -- integrate from 0 to 15, using 1000 points:
t = sc.linspace(0, 15,  1000)

x0 = 10
y0 = 5 
z0 = sc.array([x0, y0]) # initials conditions: 10 prey and 5 predators per unit area

pops, infodict = integrate.odeint(dR_dt, z0, t, full_output=True)

infodict['message']     # >>> 'Integration successful.'

prey, predators = pops.T # What's this for? - transpose
f1 = p.figure() #Open empty figure object
p.plot(t, prey, 'g-', label='Resource density') # Plot
p.plot(t, predators  , 'b-', label='Consumer density')
p.grid()
p.legend(loc='best')
p.xlabel('Time')
p.ylabel('Population')
p.title('Consumer-Resource population dynamics')
p.show()
f1.savefig('prey_and_predators_1.pdf') #Save figure
**********************************************************************

Testing LV1.py...

LV1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 10.01783s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************

#!usr/bin/python

"""5.13.2 Debugging"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports

import sys

#constants

#functions

#These functions are here to create an error
def createabug(x):
	y = x**4
	z = 0.
	y = y/z
	return y

createabug(25)

def createanewbug(x):
	y = x**4
	z = 0.
	y = y/z
	return y

createabug(10)
if (__name__ == "__main__"):
	status = main(sys.argv)
	sys.exit(status)

**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "debugme.py", line 24, in <module>
    createabug(25)
  File "debugme.py", line 21, in createabug
    y = y/z
ZeroDivisionError: float division by zero

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""5.8.3 Scope """

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports

import sys

#constants

_a_global = 10

#functions

def a_function():
		_a_global = 5 # this wont change _a_global
		_a_local = 4  # this is a local var
		print "Inside the function _a_global is ", _a_global
		print "Inside the function _a_local is ", _a_local
		return None

a_function()
print "Outside the function, the value of _a_global is", _a_global


def a_function():
		global _a_global # defining a global inside will make it global
		_a_global = 5 
		_a_local = 4
		print "Inside the function _a_global is ", _a_global
		print "Inside the function _a_local is ", _a_local
		return None
		
a_function()
print "Outside the function, the value of _a_global is", _a_global


**********************************************************************

Testing scope.py...

scope.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Inside the function _a_global is  5
Inside the function _a_local is  4
Outside the function, the value of _a_global is 10
Inside the function _a_global is  5
Inside the function _a_local is  4
Outside the function, the value of _a_global is 5

**********************************************************************

Code ran without errors

Time consumed = 0.01501s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""5.10.2 Practicals Tuple"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line for each species
# Hints: use the "print" command! You can use list comprehensions!

# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS

for bird in birds:
	print bird

**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
('Passerculus sandwichensis', 'Savannah sparrow', 18.7)
('Delichon urbica', 'House martin', 19)
('Junco phaeonotus', 'Yellow-eyed junco', 19.5)
('Junco hyemalis', 'Dark-eyed junco', 19.6)
('Tachycineata bicolor', 'Tree swallow', 20.2)

**********************************************************************

Code ran without errors

Time consumed = 0.01309s

======================================================================
Inspecting script file profilename.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""6.3.1 Profiling"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

print "Chapt 6 exercises, not yet completed"
**********************************************************************

Testing profilename.py...

profilename.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Chapt 6 exercises, not yet completed

**********************************************************************

Code ran without errors

Time consumed = 0.01627s

======================================================================
Inspecting script file basic_io.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""5.8 Practising input/output"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports

#import sys

#constants

#functions

#Practise opening and writing to files
########################################

#1 Open a file for input

f = open("../Data/test.txt", "r")

# using an implicit for loop to print lines in the files

for line in f:
	print line,
f.close()

#######################################
#2 skip lines in a file

f = open('../Data/test.txt', 'r')
for line in f:
		if len(line.strip()) > 0:
			print line,
					
f.close()

########################################

#3 save something to file

list_to_save = range(100)

f = open('../Results/testout.txt', 'w')
for i in list_to_save:
	f.write(str(i) +'\n') # f.write only writes strings, not nums hence str(i)
	
f.close()

##################################

#4 saving a more complicated object to a file

my_dictionary = {"a key" :10, "another key": 11}

import pickle

f = open('../Data/testp.p', 'wb')
pickle.dump(my_dictionary, f)
f.close()

#####################

#5 load a complicated object

f = open('../Data/testp.p', 'rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)

**********************************************************************

Testing basic_io.py...

basic_io.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
hello
hello
lines
words
blH bak blak
n
n
f
g
 h h 

hello
hello
lines
words
blH bak blak
n
n
f
g
 h h 

**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "basic_io.py", line 45, in <module>
    f = open('../Results/testout.txt', 'w')
IOError: [Errno 2] No such file or directory: '../Results/testout.txt'

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""Chapter 5 Practicals, modify lc1.py, Petra Guy
	Writing list comprehensions and for loops to extract elements from a list"""


__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"


#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 

# (2) Now do the same using conventional loops (you can shoose to do this 
# before 1 !). 

# ANNOTATE WHAT EVERY BLOCK OR, IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS


#imports


#constants

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )
#functions



#here are the list comprehension methods
#NB the x in birds selects each element of the bids list (lapply), which 
#is a list of 3)

birds_latin = [x[0] for x in birds]
print birds_latin

birds_common = [x[1] for x in birds]
print birds_common

bmi = [x[2] for x in birds]
print bmi

#This are the loops for extracting the information
latin_birds = list()
for bird in birds:
	latin_birds.append(bird[0])
print latin_birds

common_birds = list()
for bird in birds:
	common_birds.append(bird[1])
print common_birds

bird_bmi = list()
for bird in birds:
	bird_bmi.append(bird[2])
print latin_birds




**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonot
**********************************************************************

Code ran without errors

Time consumed = 0.01346s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""5.10.1. Oaks, Writing list comprehensions"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports

import sys

#constants

taxa = ["Quercus robur",
		"Fraxinus excelsior",
		"Pinus sylvestris",
		"Quercus cerris",
		"Quercus petrea", ]
		
#functions

def is_an_oak(name):
	return name.lower().startswith("quercus")
#returns all the oaks
	
oaks_loops = set()

for species in taxa:
	if is_an_oak(species):
		oaks_loops.add(species)
print oaks_loops
#loops through elements in taxa, checks them using is_an_oak, adds
#to set called oaks_loop if it is an oak.

oaks_lc = set([species for species in taxa if is_an_oak(species)])
print oaks_lc
# this line does the same as the above loop. first species is the 
#created variable, next bit is replica of the loop statement

oaks_loops = set()
for species in taxa:
	if is_an_oak(species):
		oaks_loops.add(species.upper())
print oaks_loops

oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print oaks_lc

**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
set(['Quercus robur', 'Quercus cerris', 'Quercus petrea'])
set(['Quercus robur', 'Quercus cerris', 'Quercus petrea'])
set(['QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETREA'])
set(['QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETREA'])

**********************************************************************

Code ran without errors

Time consumed = 0.01420s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""5.10 Loop exercises"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports

import sys

#constants

#functions

for i in range(5):
	print i
	
my_list = [0,2, "geronimo!", 3.0, True, False]

for k in my_list:
	print k       # just print everything in the my_list

total = 0
summands = [0,1,11,111,1111]

for s in summands:
	print total + s # adding zero?!
	
z = 0
while z < 100:
	z = z + 1
	print(z)
	
b = True
while b:
	print "Geronimo!" # b is true therefore infinite loop
	



**********************************************************************

Testing loops.py...

loops.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
11
111
1111
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
Geronimo!
Geronimo!
Geronimo!
Geronimo!
Geronimo!
Geronimo!
Geronimo!
Geronimo!
Geronimo!
Geronimo!
Geronimo!
Geronimo!
Geronimo!
Geronimo!
Geronimo!
Gero
**********************************************************************

Code ran without errors

Time consumed = 10.11316s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/python

#Filename: using_name.py

if __name__=="__main__":
		print "This program is being run by itself!!"
else:
		print "I am being imported from another module"
	
**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Marks = 98

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself!!

**********************************************************************

Code ran without errors

Time consumed = 0.01224s

======================================================================
Inspecting script file cfexercises.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""5.9.1 Control flow exercises"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports

import sys


"""print hello for various range() in for loops """
for i in range(3, 17):
	print "hello"

for j in range(12):
	if j % 3 == 0:
		print "hi"

for j in range(15):
	if j % 5 == 3:
		print "ho"
	elif j % 4 == 3:
		print "ha"
		
"""While loops"""
z = 12
while z < 100:
	if z == 31:
		for k in range(7):
			print "err"
	elif z == 18:
		print "eh"
	z = z + 1

	
def foo1(x):
	"""Sqrt input"""
	print x ** 0.5


def foo2(x,y):
	"""Returns the largest value"""
	if x > y:
		return x
	print y


def foo3(x,y,z):
	"""Sorts the three input values"""
	if x > y:
		tmp = y
		y = x
		x = tmp
	if y > z:
		tmp = z
		z = y
		y = tmp
	print [x,y,z]


def foo4(x):
	""" calculates 1*2*3...*x"""
	result = 1
	for i in range(1, x + 1):
		result = result * i
	print result




def foo5(x):
	"""Factorial using recursion"""
	print("factorial has been called with n = " + str(x))
	if x == 1:
		return 1
	else:
		res = x * foo5(x-1)
        print("intermediate result for ", x, ".....",res)
	return res	
	print res

def main(argv):
		foo1(1)
		foo2(2,9)
		foo3(3,4,5)
		foo4(4)
		foo5(4)
		
		


if (__name__ == "__main__"):
		status = main(sys.argv)
		sys.exit(status)
**********************************************************************

Testing cfexercises.py...

cfexercises.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hi
hi
hi
hi
ho
ha
ho
ha
ho
eh
err
err
err
err
err
err
err
1.0
9
[3, 4, 5]
24
factorial has been called with n = 4
factorial has been called with n = 3
factorial has been called with n = 2
factorial has been called with n = 1
('intermediate result for ', 2, '.....', 2)
('intermediate result for ', 3, '.....', 6)
('intermediate result for ', 4, '.....', 24)

**********************************************************************

Code ran without errors

Time consumed = 0.01154s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""5.12.1 Align DNA sequences"""
	

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports

import sys

#constants

data = [line.strip() for line in open("../Data/seq.csv", "r")]

seq2 = data[0]
seq1 = data[1]
l1 = len(seq1)
l2 = len(seq2)

#functions

#PS above code works because I know there are two elements in data
#This should be made more general
#seq2 = "ATCGCCGGATTACGGG"
#seq1 = "CAATTCGGAT"

# assign the longest sequence s1, and the shortest to s2
# l1 is the length of the longest, l2 that of the shortest


if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths make s1, l1 the longest

# function that computes a score
# by returning the number of matches 
# starting from arbitrary startpoint - specified below

def calculate_score(s1, s2, l1, l2, startpoint):
	"""Calculate_score matches strings from a startpoint."""
	matched = "" # contains string for alignement
	score = 0
	for i in range(l2):
		if (i + startpoint) < l1:
            # if its matching the character
			if s1[i + startpoint] == s2[i]:
				matched = matched + "*"
				score = score + 1
			else:
				matched = matched + "-"
					
    # build some formatted output
	print "." * startpoint + matched           
	print "." * startpoint + s2
	print s1
	print score 
	print ""

	return score
	
#######################################################
# running several times from different starting points
calculate_score(s1, s2, l1, l2, 0)
calculate_score(s1, s2, l1, l2, 1)
calculate_score(s1, s2, l1, l2, 5)


#######################################################
# now try to find the best match (highest score)
my_best_align = None
my_best_score = -1


# here's a loop over all the starting points given the length of l1
# this matches l2 starting at all points of l1
for i in range(l1):
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 #this many spaces from start
        my_best_score = z

print my_best_align
print s1
print "Best score:", my_best_score

f = open("../Sandbox/align_seq_out.txt","wb")
f.write(str(my_best_score))
f.write(str(my_best_align))


**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
*-----*****-
"CAATTCGGAT"
"ATCGCCGGATTACGGG"
6

.-------*--*-
."CAATTCGGAT"
"ATCGCCGGATTACGGG"
2

.....-*---*------
....."CAATTCGGAT"
"ATCGCCGGATTACGGG"
2

*-----*****-
"CAATTCGGAT"
"ATCGCCGGATTACGGG"
6

.-------*--*-
."CAATTCGGAT"
"ATCGCCGGATTACGGG"
2

..-*----------
.."CAATTCGGAT"
"ATCGCCGGATTACGGG"
1

...---------*--
..."CAATTCGGAT"
"ATCGCCGGATTACGGG"
1

....-*----------
...."CAATTCGGAT"
"ATCGCCGGATTACGGG"
1

.....-*---*------
....."CAATTCGGAT"
"ATCGCCGGATTACGGG"
2

......---***--*--*
......"C
**********************************************************************

Code ran without errors

Time consumed = 0.01728s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""5.8.2 What is sysargv"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports

import sys

print "this  is the name of the script: ", sys.argv[0]
print "Number of arguments: " ,len(sys.argv)
print "The arguments are :", str(sys.argv)


**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
this  is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are : ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.01208s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""Chapter 5 Practical Extra Credit, align fasta sequences"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports
import numpy as np
import sys

#constants

#functions


#This function opens specified file, deletes first two rows because they
#are headers. Removes commas and spaces and creates list of 1 string. This
#function creates the data in the correct format, but it only works because I
#knew the format of the fasta files. This is not good because it might not 
#be transferrable to ANY fasta file. 
def getfastafile(h):
	"""Open fasta file, convert to string"""
	data = []
	data = [line.rstrip("\n") for line in open(h, "r")]
	dataout = data[2:]
	dataout = "'".join(dataout)
	dataout = dataout.replace("'","")
	return dataout

#Takes two strings and geives the longest to string1
def makelongestnumber1 (string1, string2):
	"""Set the longest string to be called longest"""
	if len(string1) > len(string2):
		np1 = string1
		np2 = string2
	else:
		np1 = string2
		np2 = string1
	return np1, np2

#Takes entered string and converts to numpy array, required in match function
def createnumpyarray (list1):
	"""Turn string into numpy array"""
	asnumpy = np.array(list(list1))
	return asnumpy

#Takes two strings, finds longest and shortest, finds difference in length
#Longest has first character removed to replicate moving shorter along the chain
#Longest also has incrementally smaller chunks removed from the end so that
#both strings are always the same length - so can be matched as numpys
def matching (x,y):
	"""Move shorter string along longer matching as you go"""
	longest, shortest = makelongestnumber1(x,y)
	bestscore = 0
	diff = len(longest) - len(shortest)
	for i in range(diff):
		toremove = (diff - i)
		test = longest[i:-toremove]
		testnumpy = createnumpyarray(test)
		shortestnumpy = createnumpyarray(shortest)
		score = sum(testnumpy == shortestnumpy)
		print "match ", score
		if score > bestscore:
			bestscore = score
	return bestscore





def main(argv):
	h1 = getfastafile("../../Week1/Data/407228326.fasta")
	h2 = getfastafile("../../Week1/Data/407228412.fasta")
	longest,shortest = makelongestnumber1(h1,h2)
	longestasnumpy = createnumpyarray(longest)
	z = matching(longest, shortest)
	print "largest match is ", z

if (__name__ == "__main__"):
	status = main(sys.argv)
	sys.exit(status)

	
**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
match  447
match  455
match  444
match  451
match  446
match  449
match  499
match  467
match  474
match  452
match  472
match  452
match  455
match  462
match  464
match  476
match  435
match  477
match  456
match  467
match  455
match  472
match  499
match  472
match  473
match  423
match  494
match  459
match  496
match  456
match  467
match  466
match  488
match  440
match  460
match  460
match  453
match  466
match  453
match  474
match  493
match  473
match  474
match  451
match  472
match 
**********************************************************************

Code ran without errors

Time consumed = 10.00262s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""5.9 Control Statements, loops etc"""

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports

import sys

#constants

#functions

def even_or_odd(x=0): # if not specified, x should take value 0.
	"""Find whether a number x is even or odd."""
	if x % 2 == 0: #The conditional if
		return "%d is Even!" % x
	return "%d is Odd!" % x
		
def largest_divisor_five(x=120):
	"""Find which is the largest divisor of x among 2,3,4,5."""
	largest = 0
	if x % 5 == 0:
		largest = 5
	elif x % 4 == 0: #means "else, if"
		largest = 4
	elif x % 3 == 0:
		largest = 3
	elif x % 2 == 0:
		largest = 2
	else: # When all other (if, elif) conditions are not met
		return "No divisor found for %d!" % x # Each function can return a value or a variable.
	return "The largest divisor of %d is %d" % (x, largest)
	
def is_prime(x=70):
	"""Find whether an integer is prime."""
	for i in range(2, x): # "range" returns a sequence of integers
		if x % i == 0:
			print "%d is not a prime: %d is a divisor" % (x, i) #Print formatted text "%d %s %f %e" % (20,"30",0.0003,0.00003)
		return False
	print "%d is a prime!" % x
	return True
	
def find_all_primes(x=22):
	"""Find all the primes up to x"""
	allprimes = []
	for i in range(2, x + 1):
		if is_prime(i):
			allprimes.append(i)
		print "There are %d primes between 2 and %d" % (len(allprimes), x)
	return allprimes

def main(argv):
	print even_or_odd(22)
	print even_or_odd(33)
	print largest_divisor_five(120)
	print largest_divisor_five(121)
	print is_prime(60)
	print is_prime(59)
	print find_all_primes(100)
	return 0

if (__name__ == "__main__"):
	status = main(sys.argv)
	sys.exit(status)


**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
False
2 is a prime!
There are 1 primes between 2 and 100
There are 1 primes between 2 and 100
4 is not a prime: 2 is a divisor
There are 1 primes between 2 and 100
There are 1 primes between 2 and 100
6 is not a prime: 2 is a divisor
There are 1 primes between 2 and 100
There are 1 primes between 2 and 100
8 is not a prime: 2 is a divisor
There are 1 primes between 2 and 100
Th
**********************************************************************

Code ran without errors

Time consumed = 0.01182s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!usr/bin/python

"""Doctest example"""

#NB, import doctest. put >>> function, after the def and before the 
#function calcs. doctest will cf your output strings to output from
#function. put the doctest.testmod() at the end.

__author__ = "Petra Guy, pg5117@ic.ac.uk"
__version__ = "2.7"

#imports
import sys
import doctest

def even_or_odd(x=0): 
	"""Find whether a number x is even or odd
	>>> even_or_odd(10)
	'10 is Even'
	
	>>> even_or_odd(5)
	'5 is Odd'
	
	what happens when float is provided
	>>> even_or_odd(3.2)
	'3 is Odd'
	
	what happens with -ve
	>>> even_or_odd(-2)
	'-2 is Even'
	
	"""
	#Define function to be tested
	if x % 2 == 0:
		return "%d is Even" % x
	return "%d is Odd" % x

doctest.testmod() # runs the test
**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.03564s

======================================================================
======================================================================
Finished running scripts

Ran into 4 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Marks for the Week = 98

NOTE THAT THESE ARE NOT THE FINAL MARKS FOR THE WEEK, BUT AN UPPER BOUND ON THE MARKS!