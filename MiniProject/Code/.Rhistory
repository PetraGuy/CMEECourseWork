index = sample((1:3),1)
coord = X[[index]]
x2 = coord[[1]]
y2 = coord[[2]]
x1 = (0.5*x2 + 0.5*x1)
y1 = (0.5*y2 + 0.5*y1)
x = c(x, x1)
y = c(y, y1)
}
plot(x , y, cex = 0.2)
}
chaos_game()
chaos_game = function(){
graphics.off()
#browser()
x = vector()
y = vector()
X <- list(c(0,0),c(3,4),c(4,1))
coord = X[[1]]
x1 = coord[[1]]
y1 = coord[[2]]
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
points(x1,y1, cex = 0.2)
for (i in 1:500){
index = sample((1:3),1)
coord = X[[index]]
x2 = coord[[1]]
y2 = coord[[2]]
x1 = (0.5*x2 + 0.5*x1)
y1 = (0.5*y2 + 0.5*y1)
x = c(x, x1)
y = c(y, y1)
}
plot(x , y, cex = 0.2)
}
chaos_game()
chaos_game = function(){
graphics.off()
#browser()
x = vector()
y = vector()
X <- list(c(0,0),c(3,4),c(4,1))
coord = X[[1]]
x1 = coord[[1]]
y1 = coord[[2]]
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
points(x1,y1, cex = 0.2)
for (i in 1:1000){
index = sample((1:3),1)
coord = X[[index]]
x2 = coord[[1]]
y2 = coord[[2]]
x1 = (0.5*x2 + 0.5*x1)
y1 = (0.5*y2 + 0.5*y1)
x = c(x, x1)
y = c(y, y1)
}
plot(x , y, cex = 0.2)
}
chaos_game()
knitr::opts_chunk$set(echo = TRUE)
chaos_game = function(){
graphics.off()
#browser()
x = vector()
y = vector()
X <- list(c(0,0),c(3,4),c(4,1))
coord = X[[1]]
x1 = coord[[1]]
y1 = coord[[2]]
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
points(x1,y1, cex = 0.2)
for (i in 1:1000){
index = sample((1:3),1)
coord = X[[index]]
x2 = coord[[1]]
y2 = coord[[2]]
x1 = (0.5*x2 + 0.5*x1)
y1 = (0.5*y2 + 0.5*y1)
x = c(x, x1)
y = c(y, y1)
}
plot(x , y, cex = 0.2)
}
chaos_game()
start = c(1,2)
start[1]
turtle = function(start, length, direction){
x = start[1]
y =  start[2]
x2 = x + length*cos(direction)
y2 = y + length*sin(direction)
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
arrows(x,y,x2,y2)
}
turtle(c(0,0),5,0.785)
?arrows
x = start[1]
y =  start[2]
x2 = x + length*cos(direction)
y2 = y + length*sin(direction)
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
abline(x,y,x2,y2)
x = start[1]
y =  start[2]
x2 = x + length*cos(direction)
y2 = y + length*sin(direction)
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
segments(x,y,x2,y2)
x = start[1]
y =  start[2]
x2 = x + length*cos(direction)
y2 = y + length*sin(direction)
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
segments(x,y,x2,y2)
turtle(c(0,0),5,0.785)
turtle = function(start, length, direction){
x = start[1]
y =  start[2]
x2 = x + length*cos(direction)
y2 = y + length*sin(direction)
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
segments(x,y,x2,y2)
}
turtle(c(0,0),5,0.785)
?direction
direction = (pi/4 - direction)
direction = 1.04
direction = pi/4 - direction
direction
sin(direction)
elbow(c(0,0), 1,1.04)
elbow = function(start,line, direction) {
endpoints = turtle(start,line,direction)
line = 0.95*line
direction = (pi/4 - direction)
nextpoint = turtle(endpoints, line, direction)
}
elbow(c(0,0), 1,1.04)
x = turtle(c(0,0),1,1.04)
x
turtle = function(start, line, direction){
x = start[1]
y =  start[2]
x2 = x + line*cos(direction)
y2 = y + line*sin(direction)
segments(x,y,x2,y2)
endpoints = c(x2,y2)
return(endpoints)
}
x = turtle(c(0,0),1,1.04)
x
elbow(c(0,0),1,1.04)
elbow = function(start,line, direction) {
endpoints = turtle(start,line,direction)
line = 0.95*line
direction = (7*pi/4)
nextpoint = turtle(endpoints, line, direction)
}
elbow(c(0,0),1,1.04)
elbow = function(start,line, direction) {
endpoints = turtle(start,line,direction)
line = 0.95*line
direction = -1*(7*pi/4)
nextpoint = turtle(endpoints, line, direction)
}
elbow(c(0,0),1,1.04)
elbow = function(start,line, direction) {
endpoints = turtle(start,line,direction)
line = 0.95*line
direction = pi/4 - direction
nextpoint = turtle(endpoints, line, direction)
}
elbow(c(0,0),1,1.04)
elbow = function(start,line, direction) {
endpoints = turtle(start,line,direction)
line = 0.95*line
direction = -1*(pi/4 - direction)
nextpoint = turtle(endpoints, line, direction)
}
elbow(c(0,0),1,1.04)
graphics.off()
elbow(c(0,0),1,1.04)
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
elbow(c(0,0),1,1.04)
turtle = function(start, line, direction){
x = start[1]
y =  start[2]
x2 = x + line*cos(direction)
y2 = y + line*sin(direction)
segments(x,y,x2,y2)
endpoints = c(x2,y2)
return(endpoints)
}
elbow = function(start,line, direction) {
endpoints = turtle(start,line,direction)
line = 0.95*line
direction = -1*(pi/4 - direction)
nextpoint = turtle(endpoints, line, direction)
}
elbow(c(0,0),1,1.04)
elbow = function(start,line, direction) {
browser()
endpoints = turtle(start,line,direction)
line = 0.95*line
direction = (pi/4 - direction)
nextpoint = turtle(endpoints, line, direction)
}
elbow(c(0,0),1,1.04)
elbow(c(0,0),1,1.04)
elbow = function(start,line, direction) {
browser()
graphics.off()
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
endpoints = turtle(start,line,direction)
line = 0.95*line
direction = (pi/4 - direction)
nextpoint = turtle(endpoints, line, direction)
}
turtle = function(start, line, direction){
x = start[1]
y =  start[2]
x2 = x + line*cos(direction)
y2 = y + line*sin(direction)
segments(x,y,x2,y2)
endpoints = c(x2,y2)
return(endpoints)
}
elbow = function(start,line, direction) {
browser()
graphics.off()
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
endpoints = turtle(start,line,direction)
line = 0.95*line
direction = (pi/4 - direction)
nextpoint = turtle(endpoints, line, direction)
}
elbow(c(0,0),1,1.04)
endpoints
turtle = function(start, line, direction){
x = start[1]
y =  start[2]
x2 = x - line*cos(direction)
y2 = y -line*sin(direction)
segments(x,y,x2,y2)
endpoints = c(x2,y2)
return(endpoints)
}
elbow = function(start,line, direction) {
browser()
graphics.off()
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
endpoints = turtle(start,line,direction)
line = 0.95*line
direction = (pi/4 - direction)
nextpoint = turtle(endpoints, line, direction)
}
elbow(c(0,0),1,1.04)
plot(NA, xlim=c(0,5), ylim=c(0,5), xlab="X", ylab="Y")
turtle = function(start, distance, direction){
x1 = start[1]
y1 = start[2]
x2 = x1 + distance*cos(direction)
y2 = y1 + distance*sin(direction)
segments(x1,y1,x2,y2)
coords = c(x2,y2)
return(coords)
}
elbow = function(start, distance, direction){
#browser()
coords = turtle(start, distance, direction)
direction = -1* (pi - direction - pi/4)
distance = 0.95*distance
coords = turtle(coords, distance, direction)
}
spiral = function(start, distance, direction){
coords = turtle(start, distance, direction)
direction = -1* (pi - direction - pi/4)
distance = 0.95*distance
#coords = turtle(coords, distance, direction)
if (distance > 0.1)
spiral(coords,distance,direction)
}
graphics.off()
plot(NA, xlim=c(0,1), ylim=c(0,1), xlab="X", ylab="Y")
spiral_2 = function(start, distance, direction){
coords = turtle(start, distance, direction)
if (distance > 0.1){
#direction = -1* (pi - direction - pi/4)
distance = 0.95*distance
spiral(coords,distance = 0.95*distance, direction = (-1* (pi - direction - pi/4)))
}
}
graphics.off()
plot(NA, xlim=c(0,50), ylim=c(0,50), xlab="X", ylab="Y")
tree = function(start, distance, direction) {
coords = turtle(start, distance, direction)
#coords = turtle(start, distance, direction)
if (distance > 0.1){
distance = 0.65*distance
tree(coords, distance= 0.65*distance, direction = (pi/4) )
tree(coords, distance= 0.65*distance, direction = (3*pi/4) )
}
}
graphics.off()
plot(NA, xlim=c(0,2), ylim=c(0,5), xlab="X", ylab="Y")
fern = function(start, distance, direction) {
coords = turtle(start, distance, direction)
distance1 = distance
distance2 = distance
#coords = turtle(start, distance, direction)
if (distance > 0.1){
distance = 0.9*distance
fern(coords, distance = 0.38*distance1, direction = 3*pi/4 )
fern(coords, distance= 0.87*distance2, direction = (pi/2) )
}
}
plot(NA, xlim=c(0,2), ylim=c(0,5), xlab="X", ylab="Y")
graphics.off()
plot(NA, xlim=c(0,2), ylim=c(0,5), xlab="X", ylab="Y")
fern(c(1,0),1,1)
graphics.off()
plot(NA, xlim=c(0,2), ylim=c(0,10), xlab="X", ylab="Y")
fern(c(1,0),1,1)
graphics.off()
plot(NA, xlim=c(0,2), ylim=c(0,10), xlab="X", ylab="Y")
fern = function(start, distance, direction) {
coords = turtle(start, distance, direction)
distance1 = distance
distance2 = distance
#coords = turtle(start, distance, direction)
if (distance > 0.01){
distance = 0.9*distance
fern(coords, distance = 0.38*distance1, direction = 3*pi/4 )
fern(coords, distance= 0.87*distance2, direction = (pi/2) )
}
}
fern(c(1,0),1,1)
fern = function(start, distance, direction) {
coords = turtle(start, distance, direction)
distance1 = distance
distance2 = distance
#coords = turtle(start, distance, direction)
if (distance > 0.01){
distance = 0.9*distance
fern(coords, distance = 0.38*distance1, direction = 3*pi/4 )
fern(coords, distance= 0.75*distance2, direction = (pi/2) )
}
}
fern2 = function(start, distance, direction) {
coords = turtle(start, distance, direction)
distance1 = distance
distance2 = distance
#coords = turtle(start, distance, direction)
if (distance > 0.01){
distance = 0.9*distance
fern(coords, distance = 0.38*distance1, direction = 3*pi/4 )
fern(coords, distance= 0.75*distance2, direction = (pi/2) )
}
}
graphics.off()
plot(NA, xlim=c(0,2), ylim=c(0,10), xlab="X", ylab="Y")
fern2(c(1,0),1,1)
graphics.off()
plot(NA, xlim=c(0,2), ylim=c(0,10), xlab="X", ylab="Y")
fern2(c(1,0),0.7,1)
knitr::opts_chunk$set(echo = TRUE)
graphics.off()
plot(NA, xlim=c(0,2), ylim=c(0,10), xlab="X", ylab="Y")
fern = function(start, distance, direction) {
coords = turtle(start, distance, direction)
distance1 = distance
distance2 = distance
#coords = turtle(start, distance, direction)
if (distance > 0.01){
distance = 0.9*distance
fern(coords, distance = 0.38*distance1, direction = 3*pi/4 )
fern(coords, distance= 0.87*distance2, direction = (pi/2) )
}
}
fern(c(1,0),1,1)
load("/home/petra/Documents/CMEECourseWork/HPC/Results/Cluster_1207/pg5117/pg5117_cluster_1.rda")
knitr::opts_chunk$set(echo = TRUE)
#clear the workspace
rm(list = ls())
cat("\014")
setwd("~/Documents/CMEECourseWork/MiniProject/Code")
library(randomForest)
library(ggplot2)
library(gridExtra)
library(GGally)
library(grid)
library(reshape2)
library(caret)
library(rpart)
library(rattle)
install.packages("rattle", lib = "/home/petra/R/x86_64-pc-linux-gnu-library/3.2
")
library(rattle)
install.packages("rattle", dependencies = TRUE)
library(rattle)
library(rpart.plot)
?fancyRpart
?rpart.plot
set.seed(43)
soraria_rpart_tree = rpart(Species~., soraria_train, method = "class")
#using random forest package
#create the train test split to be used for model tuning.
n = nrow(Imputed_df)
#clear the workspace
rm(list = ls())
cat("\014")
setwd("~/Documents/CMEECourseWork/MiniProject/Code")
library(randomForest)
library(ggplot2)
library(gridExtra)
library(GGally)
library(grid)
library(reshape2)
library(caret)
library(rpart)
#library(rattle) this will not install
library(rpart.plot)
library(RColorBrewer)
#Get the data , enter input CSV file name here, for data in data directory
inputfile = 'SorariaCompact1.csv'
Dataname = strsplit(inputfile, "\\.")[[1]][[1]]
fullfile = paste("../Data",inputfile,sep = '/')
Data = read.csv(fullfile)
setwd("~/Documents/CMEECourseWork/MiniProject/Code")
#Get the data , enter input CSV file name here, for data in data directory
inputfile = 'SorariaCompact1.csv'
Dataname = strsplit(inputfile, "\\.")[[1]][[1]]
fullfile = paste("../Data",inputfile,sep = '/')
Data = read.csv(fullfile)
#Do some median imputations, carried out after the data was manipulated as described above - #hence reducing the number or rows that were imputed.
median_replace1 = function(x){
ifelse(is.na(x), median(x,na.rm = TRUE), x)
}
median_replace2 = function(x){
apply(x,2,median_replace1)
}
Imputed_list = lapply(split.data.frame(Data[,2:12], Data$Species), FUN = median_replace2)
#The imputed dataframe is a list with species as the elements, the following sticks it back together with a different name so both optiona are available
temp = do.call(rbind, Imputed_list)
Imputed_df = cbind(Data[1], temp)
#using random forest package
#create the train test split to be used for model tuning.
n = nrow(Imputed_df)
n_train = round(0.8*n)
set.seed(42) # change the seed to create new train and test sets
train_indices = sample(1:n, n_train)
soraria_train = Imputed_df[train_indices,]
soraria_test = Imputed_df[-train_indices,]
soraria_randomforest = randomForest(formula = Species~., data = Imputed_df, mtry = 6, keep.forest = FALSE)
plot(soraria_forest)
soraria_randomforest = randomForest(formula = Species~., data = Imputed_df, mtry = 6, keep.forest = FALSE)
plot(soraria_randomforest)
legend(x = "right", legend = colnames(err), fill = 1:ncol(err))
#using random forest package
#create the train test split to be used for model tuning.
n = nrow(Imputed_df)
n_train = round(0.8*n)
set.seed(42) # change the seed to create new train and test sets
train_indices = sample(1:n, n_train)
soraria_train = Imputed_df[train_indices,]
soraria_test = Imputed_df[-train_indices,]
soraria_randomforest = randomForest(formula = Species~., data = Imputed_df, mtry = 6, keep.forest = FALSE)
err = soraria_randomforest$err.rate
plot(soraria_randomforest)
legend(x = "right", legend = colnames(err), fill = 1:ncol(err))
#tuning the mtry
res = tuneRF(x = soraria_train,
y = soraria_train$Species,
ntreeTry = 500)
print(res)
mtry_opt = res[,"mtry"][which.min(res[,"OOBError"])]
set.seed(43)
soraria_rpart_tree = rpart(Species~., soraria_train, method = "class")
rpart.plot(soraria_rpart_tree)
?rpart
pred = predict(soraria_rpart_tree, soraria_test, type = "class")
conf = table(soraria_test$Species, pred)
print(sum(diag(conf))/sum(conf))
print(conf)
set.seed(43)
soraria_rpart_tree = rpart(Species~., soraria_train, method = "class", parms = "information")
set.seed(43)
soraria_rpart_tree = rpart(Species~., soraria_train, method = "class", parms = information)
set.seed(43)
soraria_rpart_tree = rpart(Species~., soraria_train, method = "class", parms = list(split = "information"))
rpart.plot(soraria_rpart_tree)
set.seed(43)
soraria_rpart_tree = rpart(Species~., soraria_train, method = "class", parms = list(split = "gini"))
rpart.plot(soraria_rpart_tree)
library(repr)
set.seed(42)
soraria_tree_caret_ranger = train(Species~., data = Imputed_df, method = "ranger", tuneLength =11,
trControl= trainControl(method = "cv", number = 5, summaryFunction = defaultSummary, classProbs = TRUE))
plot(soraria_tree_caret_ranger)
print(soraria_tree_caret_ranger)
rpart.plot(soraria_tree_caret_ranger$finalModel)
summary(soraria_tree_caret_ranger$finalModel)
plot(soraria_tree_caret_ranger$finalModel)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggraph)
install.packages("ggraph")
library(dplyr)
library(ggraph)
library(ggraph)
library(ggraph)
