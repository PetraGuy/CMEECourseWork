lapply(MedianImputedDF[-1], pairs)
#ggplot scatterplots grouped by species
ggplot(soraria_df, aes(x = LeafLength, y = LeafWidth, col = Species)) +
geom_point()
#boxplots for everything
soraria_df_colnames <- colnames(soraria_df)
soraria_df_colnames <- soraria_df_colnames[-1]
plotlist = list()
for (i in seq_along(soraria_df_colnames)){
plot <- ggplot(soraria_df, (aes_string(x= "Species", y = soraria_df_colnames[i]))) + geom_boxplot()
plotlist <- rbind(plotlist, plot)
grid.draw(plot)
}
## put histograms on the diagonal
panel.hist <- function(x, ...)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(usr[1:2], 0, 1.5) )
h <- hist(x, plot = FALSE)
breaks <- h$breaks; nB <- length(breaks)
y <- h$counts; y <- y/max(y)
rect(breaks[-nB], 0, breaks[-1], y, col = "cyan", ...)
}
pairs(soraria_df[-1,c(2:9)], panel = panel.smooth,
cex = 1.5, pch =10 , bg = "light blue",
diag.panel = panel.hist, cex.labels = 2, font.labels = 2)
set.seed(1)
# Chop up iris in my_iris and species
my_soraria <- as.matrix(SorariaImpute[-1])
species <- soraria_df$Species
# Perform k-means clustering on my_soraria: kmeans_soraria
kmeans_soraria <- kmeans(my_soraria, 6)
# Compare the actual Species to the clustering using table()
table(species, kmeans_soraria$cluster)
plot(Petal.Length ~ Petal.Width, data = my_iris, col = kmeans_iris$cluster)
set.seed(1)
# Chop up iris in my_iris and species
my_soraria <- as.matrix(SorariaImpute[-1])
species <- soraria_df$Species
# Perform k-means clustering on my_soraria: kmeans_soraria
kmeans_soraria <- kmeans(my_soraria, 6)
# Compare the actual Species to the clustering using table()
table(species, kmeans_soraria$cluster)
plot(Petal.Length ~ Petal.Width, data = my/-soraria, col = kmeans_iris$cluster)
set.seed(1)
# Chop up iris in my_iris and species
my_soraria <- as.matrix(SorariaImpute[-1])
species <- soraria_df$Species
# Perform k-means clustering on my_soraria: kmeans_soraria
kmeans_soraria <- kmeans(my_soraria, 6)
# Compare the actual Species to the clustering using table()
table(species, kmeans_soraria$cluster)
set.seed(1)
# Chop up soraria in my_soraria and species
my_soraria <- as.matrix(SorariaImpute[-1])
species <- soraria_df$Species
# Perform k-means clustering on my_soraria: kmeans_soraria
kmeans_soraria <- kmeans(my_soraria, 6)
# Compare the actual Species to the clustering using table()
table(species, kmeans_soraria$cluster)
plot(Petal.Length ~ Petal.Width, data = my_soraria, col = kmeans_soraria$cluster)
my_soraria <- as.matrix(SorariaImpute[-1])
SorariaSpecies <- soraria_df[1] # make a list of the factors
# make sure its a df and not a list, otherwise tapply doesnt work
sorariatemp <- soraria_df
sorariatemp["Species"] <-NULL #the species column is removed
newdf<- as.data.frame(sorariatemp) # turn numbers chunk into df
sorariaAsdf <- cbind(soraria_df[1], newdf) # species back on, now whole thing is df
# this applies the function to a the first column, by factors listed in species, but produces list of 6
# medimputeCol <- tapply(sorariaAsdf[[i]], SorariaSpecies, function(x) ifelse(is.na(x), median(x, na.rm = TRUE), x))
#dont know how to turn this back into df of two cols, species and value inc median
#Here got medians for column 2 - leaf length
medimputeCol <- tapply(sorariaAsdf[[2]], SorariaSpecies, function(x) ifelse(is.na(x), median(x, na.rm = TRUE), x))
# then this unlists and turns into a df
medimputedf <- matrix(unlist(medimputeCol), nrow = 682, byrow = TRUE, dimnames = SorariaSpecies)
# scatterplot matrix
library(ggplot2)
#do pairs plots for each species
lapply(MedianImputedDF[-1], pairs)
#ggplot scatterplots grouped by species
ggplot(soraria_df, aes(x = LeafLength, y = LeafWidth, col = Species)) +
geom_point()
#boxplots for everything
soraria_df_colnames <- colnames(soraria_df)
soraria_df_colnames <- soraria_df_colnames[-1]
plotlist = list()
for (i in seq_along(soraria_df_colnames)){
plot <- ggplot(soraria_df, (aes_string(x= "Species", y = soraria_df_colnames[i]))) + geom_boxplot()
plotlist <- rbind(plotlist, plot)
grid.draw(plot)
}
## put histograms on the diagonal
panel.hist <- function(x, ...)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(usr[1:2], 0, 1.5) )
h <- hist(x, plot = FALSE)
breaks <- h$breaks; nB <- length(breaks)
y <- h$counts; y <- y/max(y)
rect(breaks[-nB], 0, breaks[-1], y, col = "cyan", ...)
}
pairs(soraria_df[-1,c(2:9)], panel = panel.smooth,
cex = 1.5, pch =10 , bg = "light blue",
diag.panel = panel.hist, cex.labels = 2, font.labels = 2)
set.seed(1)
# Chop up soraria in my_soraria and species
my_soraria <- as.matrix(SorariaImpute[-1])
species <- soraria_df$Species
# Perform k-means clustering on my_soraria: kmeans_soraria
kmeans_soraria <- kmeans(my_soraria, 6)
# Compare the actual Species to the clustering using table()
table(species, kmeans_soraria$cluster)
plot(Petal.Length ~ Petal.Width, data = my_soraria, col = kmeans_soraria$cluster)
my_soraria <- as.matrix(SorariaImpute[-1])
# calculate medians and fill in NAs for each group with median
#this bit says if is NA, calculate a median
medianreplace1 <- function(x) {
ifelse(is.na(x), median(x, na.rm = TRUE), x)
}
#this bit does above, but in an apply
medianreplace2 <- function(x){
apply(x, 2,medianreplace1)
}
# now use that function in aggregate to calc median
#split the dataframe by species into a list of dataframes per species
#lapply works over this list
#apply works over the cols within each dataframe of the list
MedianImputedDF <- lapply(split.data.frame(soraria_df[,2:9], soraria_df$Species), FUN = medianreplace2)
#Above is a list of dataframes, each element is a species,
#to join them back up row by row, with col 1 is species do this
temp <- do.call(rbind, MedianImputedDF) #PS unplsit did not work, needed this do. call thing
SorariaImpute <- cbind(soraria_df[1], temp)
# Now I need to unsplit the "newthing"
# this calculates the medians and gives you a dataframe, just so you know them
#doesnt replace
#
median1 <- function(x) {
median(x, na.rm = TRUE)
}
mediansAre <- aggregate(soraria_df[,2:9], soraria_df[1], median1)
set.seed(1)
# Chop up soraria in my_soraria and species
my_soraria <- as.matrix(SorariaImpute[-1])
species <- soraria_df$Species
# Perform k-means clustering on my_soraria: kmeans_soraria
kmeans_soraria <- kmeans(my_soraria, 6)
# Compare the actual Species to the clustering using table()
table(species, kmeans_soraria$cluster)
plot(Petal.Length ~ Petal.Width, data = my_soraria, col = kmeans_soraria$cluster)
View(my_soraria)
View(my_soraria)
plot(LeafLength ~ LeafWidth, data = my_soraria, col = kmeans_soraria$cluster)
lapply(MedianImputedDF[-1], pairs)
lapply(MedianImputedDF[-1], pairs)
#a random forest train needs caret
library(caret)
Y = soraria_df[,1]
X = soraria_df[,2:11]
random_forest_soraria <-  train(X, Y,
#tuneGrid = data.frame(mtry = c(2, 3, 7)),
data = soraria_df,
method = "ranger",
preProcess = c("medianImpute","center","scale"),
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE))
??train
library(caret)
library("caret")
library(caret)
install.packages(caret)
install.packages("caret")
library("caret")
library(caret)
Y = soraria_df[,1]
X = soraria_df[,2:11]
random_forest_soraria <-  train(X, Y,
#tuneGrid = data.frame(mtry = c(2, 3, 7)),
data = soraria_df,
method = "ranger",
preProcess = c("medianImpute","center","scale"),
trControl = trainControl(method = "cv", number = 5, verboseIter = TRUE))
ggplot(soraria_df, aes(x = LeafLength, y = LeafWidth, col = Species)) +
geom_point()
set.seed(1)
# Chop up soraria in my_soraria and species
my_soraria <- as.matrix(SorariaImpute[-1])
species <- soraria_df$Species
# Perform k-means clustering on my_soraria: kmeans_soraria
kmeans_soraria <- kmeans(my_soraria, 6)
# Compare the actual Species to the clustering using table()
table(species, kmeans_soraria$cluster)
plot(LeafLength ~ LeafWidth, data = my_soraria, col = kmeans_soraria$cluster)
library(ggplot2)
set.seed(1)
# Chop up soraria in my_soraria and species
my_soraria <- as.matrix(SorariaImpute[-1])
species <- soraria_df$Species
# Perform k-means clustering on my_soraria: kmeans_soraria
kmeans_soraria <- kmeans(my_soraria, 6)
# Compare the actual Species to the clustering using table()
table(species, kmeans_soraria$cluster)
plot(LeafLength ~ LeafWidth, data = my_soraria, col = kmeans_soraria$cluster)
plot(LeafLength ~ LeafWidth, data = my_soraria, col = kmeans_soraria$cluster)
#Import Soraria data set
dev.off()       # close current plots
rm(list = ls()) # clear env
cat("\014")     # clear console
library("openxlsx")
# workbook details
path = "C:/Users/Petra Guy/Google Drive/R/Projects/Sorbus/DataFiles"
file = "SorariaComplete.xlsx"
sheets = c("Anglica",
"Cuneifolia",
"Intermedia",
"Leyana",
"Minima",
"Mougeotii")
# join path and filename
pathfile = paste(path, file, sep="/")
# open the file with this package
xlsxFile = loadWorkbook(file = pathfile)
soraria_df = data.frame()
for (sheet in sheets){
# load data into dataframe
df = read.xlsx(xlsxFile = xlsxFile, sheet = sheet, skipEmptyRows = FALSE)
soraria_df = rbind(soraria_df, df)
}
# calculate medians and fill in NAs for each group with median
#this bit says if is NA, calculate a median
medianreplace1 <- function(x) {
ifelse(is.na(x), median(x, na.rm = TRUE), x)
}
#this bit does above, but in an apply
medianreplace2 <- function(x){
apply(x, 2,medianreplace1)
}
# now use that function in aggregate to calc median
#split the dataframe by species into a list of dataframes per species
#lapply works over this list
#apply works over the cols within each dataframe of the list
MedianImputedDF <- lapply(split.data.frame(soraria_df[,2:9], soraria_df$Species), FUN = medianreplace2)
#Above is a list of dataframes, each element is a species,
#to join them back up row by row, with col 1 is species do this
temp <- do.call(rbind, MedianImputedDF) #PS unplsit did not work, needed this do. call thing
SorariaImpute <- cbind(soraria_df[1], temp)
set.seed(1)
# Chop up soraria in my_soraria and species
my_soraria <- as.matrix(SorariaImpute[-1])
species <- soraria_df$Species
# Perform k-means clustering on my_soraria: kmeans_soraria
kmeans_soraria <- kmeans(my_soraria, 6)
# Compare the actual Species to the clustering using table()
table(species, kmeans_soraria$cluster)
plot(LeafLength ~ LeafWidth, data = my_soraria, col = kmeans_soraria$cluster)
plot(FruitLength ~ FruitWidth, data = my_soraria, col = kmeans_soraria$cluster)
View(my_soraria)
View(my_soraria)
MedianImputedDF
iris
clusters <- hclust(dist(my_soraria[,2:3]))
plot(clusters)
clusters <- hclust(dist(my_soraria[,2:3]), method = 'average')
plot(clusters)
# Apply median imputation: model
soraria_x <- as.matrix(soraria_df[,2:11])
soraria_y <- as.matrix(soraria_df[1])
myControl <- trainControl(
method = "cv", number = 10,
#summaryFunction = twoClassSummary,
classProbs = TRUE, # IMPORTANT!
verboseIter = TRUE
)
model_knn <- train(
x = soraria_x, y = soraria_y,
method = "knn",
trControl = myControl,
preProcess = "medianImpute"
)
# Print model to console
model_knn
model_rf <- train(
x = soraria_x, y = soraria_y,
method = "ranger",
trControl = myControl,
preProcess = "medianImpute"
)
# Print model to console
model_knn
model_rf
parts <- colnames(soraria_df)
expvars <- as.vector(parts[-1])
library(rpart)
# using a tree model from intro to machine learning, lesson 12
tree <- rpart(Species ~ LeafLength + LeafWidth + WidestPoint + Angle,
data = soraria_df, method = "class")
# A dataframe containing unseen observations
#unseen <- data.frame(Sepal.Length = c(5.3, 7.2),
##  Sepal.Width = c(2.9, 3.9),
Petal.Length = c(1.7, 5.4),
# Petal.Width = c(0.8, 2.3))
# Predict the label of the unseen observations. Print out the result.
predict(tree, unseen, type = 'class')
model_knn
model_rf
parts <- colnames(soraria_df)
expvars <- as.vector(parts[-1])
library(rpart)
# using a tree model from intro to machine learning, lesson 12
tree <- rpart(Species ~ LeafLength + LeafWidth + WidestPoint + Angle,
data = soraria_df, method = "class")
# A dataframe containing unseen observations
#unseen <- data.frame(Sepal.Length = c(5.3, 7.2),
##  Sepal.Width = c(2.9, 3.9),
#  Petal.Length = c(1.7, 5.4),
# Petal.Width = c(0.8, 2.3))
# Predict the label of the unseen observations. Print out the result.
predict(tree, unseen, type = 'class')
# Print model to console
model_knn
model_rf
parts <- colnames(soraria_df)
expvars <- as.vector(parts[-1])
library(rpart)
# using a tree model from intro to machine learning, lesson 12
tree <- rpart(Species ~ LeafLength + LeafWidth + WidestPoint + Angle,
data = soraria_df, method = "class")
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
p = seq(from 0.1, to 0.9, by 0.1)
p = seq(from 0.1, to = 0.9, by 0.1)
p = seq(from 0.1, to = 0.9, by = 0.1)
p = seq(from= 0.1, to = 0.9, by = 0.1)
prior = c(rep(0.6, 4), 0.52, rep(0.6,4))
likelihood = dbinom(4, size = 20, prob = p)
p = seq(from= 0.1, to = 0.9, by = 0.1)
prior = c(rep(0.6, 4), 0.52, rep(0.6,4))
likelihood = dbinom(4, size = 20, prob = p)
print(likelihood)
?round
p = seq(from= 0.1, to = 0.9, by = 0.1)
prior = c(rep(0.6, 4), 0.52, rep(0.6,4))
likelihood = dbinom(4, size = 20, prob = p)
print(round(likelihood, digits = 3)
p = seq(from= 0.1, to = 0.9, by = 0.1)
prior = c(rep(0.6, 4), 0.52, rep(0.6,4))
likelihood = dbinom(4, size = 20, prob = p)
print(round(likelihood, digits = 3))
p = seq(from= 0.1, to = 0.9, by = 0.1)
prior = c(rep(0.6, 4), 0.52, rep(0.6,4))
likelihood = dbinom(4, size = 20, prob = p)
print(round(likelihood, digits = 3))
numerator = prior*likelihood
denominator = sum(numerator)
posterior = numerator/denominator
sum(posterior)
p = seq(from= 0.1, to = 0.9, by = 0.1)
prior = c(rep(0.6, 4), 0.52, rep(0.6,4))
likelihood = dbinom(4, size = 20, prob = p)
print(round(likelihood, digits = 3))
numerator = prior*likelihood
denominator = sum(numerator)
posterior = numerator/denominator
sum(posterior)
print(posterior)
Data = read.csv("../Data/GroundCover.csv")
Data_Yr2 = Data%>%filter(Yr_2 == 2)#%>%select(SITE,PLOT,NEST,COV,Amalgams)
colnames(Data_Yr2) = c("SITE", "PLOT","NEST","Cover","BRC_number","Year")
veg_codes = read.csv("../Data/vegetation_codes.csv")
colnames(veg_codes) = c("Species", "BRC_number")
Data_Yr2_veg = Data_Yr2%>% inner_join(veg_codes)
library(dplyr)
Data = read.csv("../Data/GroundCover.csv")
Data_Yr2 = Data%>%filter(Yr_2 == 2)#%>%select(SITE,PLOT,NEST,COV,Amalgams)
colnames(Data_Yr2) = c("SITE", "PLOT","NEST","Cover","BRC_number","Year")
veg_codes = read.csv("../Data/vegetation_codes.csv")
colnames(veg_codes) = c("Species", "BRC_number")
Data_Yr2_veg = Data_Yr2%>% inner_join(veg_codes)
Data = read.csv("../Data/GroundCover.csv")
setwd("C:/dev/code/CMEECourseWork/CMEEMainProject/Code")
Data = read.csv("../Data/GroundCover.csv")
Data_Yr2 = Data%>%filter(Yr_2 == 2)#%>%select(SITE,PLOT,NEST,COV,Amalgams)
colnames(Data_Yr2) = c("SITE", "PLOT","NEST","Cover","BRC_number","Year")
veg_codes = read.csv("../Data/vegetation_codes.csv")
colnames(veg_codes) = c("Species", "BRC_number")
Data_Yr2_veg = Data_Yr2%>% inner_join(veg_codes)
# now using Dat_Yr2_veg means analysis is carried out without bryophytes
data_plots = read.csv("../Data/PlotVars.csv") # this provides pH, livebasal area, SOM
View(data_plots)
data_rich = read.csv("../Data/plot_rich.csv")
y = all_plot_vars$plot_richness
x1 = as.factor(all_plot_vars$ShortNVC)
x2= as.factor(round(all_plot_vars$pHYr2, digits = 0))
x3 = as.factor(round(all_plot_vars$SOMYr2, digits = 0))
x4 = as.factor(round(all_plot_vars$LiveBasalAreaYr2, digits = 0))
x5 =  as.factor(round(all_plot_vars$mean_dbh, digits = 0))
x6 =  as.factor(round(all_plot_vars$`tree density`, digits = 1))
data_dbh_long = data.frame()
Plot = c(1:16)
for (i in 1:103){
r = as.vector(t(data_dbh[i, c(2:17)]))
Site = rep(i,16)
tmp = as.data.frame(cbind(Site,Plot,r))
colnames(tmp) = c("Site","Plot","mean_dbh")
data_dbh_long = rbind(data_dbh_long,tmp)
}
data_density_long = data.frame()
Plot = c(1:16)
for (i in 1:103){
r = as.vector(t(data_tree_density[i, c(2:17)]))
Site = rep(i,16)
tmp = as.data.frame(cbind(Site,Plot,r))
colnames(tmp) = c("Site","Plot","tree density")
data_density_long = rbind(data_density_long,tmp)
}
data_rich_long = data.frame()
Plot = c(1:16)
for (i in 1:103){
r = as.vector(t(data_rich[i, c(2:17)]))
Site = rep(i,16)
tmp = as.data.frame(cbind(Site,Plot,r))
colnames(tmp) = c("Site","Plot","plot_richness")
data_rich_long = rbind(data_rich_long,tmp)
}
#join tmp plot vars with data dbh long, data density long and data rich long
tmp_all = inner_join(tmp_plot_vars,data_dbh_long)
tmp_all = inner_join(tmp_all, data_density_long)
all_plot_vars = inner_join(tmp_all, data_rich_long)
all_plot_vars$ShortNVC = gsub("[[:lower:]]","",all_plot_vars$Yr2NVC)
write.csv(all_plot_vars,"../Data/AllPlotsVarsRichness.csv")
tmp_plot_vars = data_plots[c(1,2,5,7,9,11,12,14)]
tmp_all = inner_join(tmp_plot_vars,data_dbh_long)
tmp_all = inner_join(tmp_all, data_density_long)
all_plot_vars = inner_join(tmp_all, data_rich_long)
tmp_all = inner_join(tmp_plot_vars,data_dbh_long)
Data = read.csv("../Data/GroundCover.csv")
Data_Yr2 = Data%>%filter(Yr_2 == 2)#%>%select(SITE,PLOT,NEST,COV,Amalgams)
colnames(Data_Yr2) = c("SITE", "PLOT","NEST","Cover","BRC_number","Year")
veg_codes = read.csv("../Data/vegetation_codes.csv")
colnames(veg_codes) = c("Species", "BRC_number")
Data_Yr2_veg = Data_Yr2%>% inner_join(veg_codes)
# now using Dat_Yr2_veg means analysis is carried out without bryophytes
data_plots = read.csv("../Data/PlotVars.csv") # this provides pH, livebasal area, SOM
#means come from MainProjDBH
data_dbh = read.csv("../Data/dbh_means.csv")
#tree_density calcuated in MainProjDBH, is sum of all trees over all dbh classes/200m2
#BUT - saplings only counted in 2 quadrants
data_tree_density = read.csv("../Data/tree_density.csv")
#plot_richness come from ExploringNests
data_rich = read.csv("../Data/plot_rich.csv")
#wrangle
# get data into long format of columns Site (with 16 plots), pH, SOM, etc
tmp_plot_vars = data_plots[c(1,2,5,7,9,11,12,14)]
data_dbh_long = data.frame()
Plot = c(1:16)
for (i in 1:103){
r = as.vector(t(data_dbh[i, c(2:17)]))
Site = rep(i,16)
tmp = as.data.frame(cbind(Site,Plot,r))
colnames(tmp) = c("Site","Plot","mean_dbh")
data_dbh_long = rbind(data_dbh_long,tmp)
}
data_density_long = data.frame()
Plot = c(1:16)
for (i in 1:103){
r = as.vector(t(data_tree_density[i, c(2:17)]))
Site = rep(i,16)
tmp = as.data.frame(cbind(Site,Plot,r))
colnames(tmp) = c("Site","Plot","tree density")
data_density_long = rbind(data_density_long,tmp)
}
data_rich_long = data.frame()
Plot = c(1:16)
for (i in 1:103){
r = as.vector(t(data_rich[i, c(2:17)]))
Site = rep(i,16)
tmp = as.data.frame(cbind(Site,Plot,r))
colnames(tmp) = c("Site","Plot","plot_richness")
data_rich_long = rbind(data_rich_long,tmp)
}
#join tmp plot vars with data dbh long, data density long and data rich long
tmp_all = inner_join(tmp_plot_vars,data_dbh_long)
tmp_all = inner_join(tmp_all, data_density_long)
all_plot_vars = inner_join(tmp_all, data_rich_long)
all_plot_vars$ShortNVC = gsub("[[:lower:]]","",all_plot_vars$Yr2NVC)
y = all_plot_vars$plot_richness
x1 = as.factor(all_plot_vars$ShortNVC)
x2= as.factor(round(all_plot_vars$pHYr2, digits = 0))
x3 = as.factor(round(all_plot_vars$SOMYr2, digits = 0))
x4 = as.factor(round(all_plot_vars$LiveBasalAreaYr2, digits = 0))
x5 =  as.factor(round(all_plot_vars$mean_dbh, digits = 0))
x6 =  as.factor(round(all_plot_vars$`tree density`, digits = 1))
plot(x = x2, y = y, main = "by pH")
data = as.data.frame(cbind(x3,y))
ggplot(data, aes(x = x3, y = y))+geom_boxplot()
library(ggplot2)
ggplot(data, aes(x = x3, y = y))+geom_boxplot()
data = as.data.frame(cbind(as.factor(x3),y))
ggplot(data, aes(x = x3, y = y))+geom_boxplot()
View(data)
data = as.data.frame(cbind(as.factor(x2),y))
ggplot(data, aes(x = x2, y = y))+geom_boxplot()
ggplot(data, aes(x = x2, y = y))+geom_boxplot()+
xlab("plot pH")+ylab("plot richness")
ggplot(data, aes(x = x2, y = y))+geom_boxplot()+
xlab("plot pH")+ylab("plot richness")+
theme(element_text, face = "bold")
ggplot(data, aes(x = x2, y = y))+geom_boxplot()+
xlab("plot pH")+ylab("plot richness")+
theme(element_text(face = "bold"))
ggplot(data, aes(x = x2, y = y))+geom_boxplot()+
xlab("plot pH")+ylab("plot richness")+
theme(text = element_text(size = 14, face = "bold"))
